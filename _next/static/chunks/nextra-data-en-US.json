{"/database":{"title":"Database Design","data":{"":"This section outlines the database architecture that powers Whisper Chat,\nincluding table structures, relationships, and optimization strategies.","database-architecture#Database Architecture":"Whisper uses a PostgreSQL database with specialized extensions to handle the unique requirements of a real-time messaging platform. The database is designed to optimize for:\nHigh read/write throughput\nLow-latency queries\nData integrity and consistency\nEfficient search capabilities\nScalability for millions of users and messages","schema-diagram#Schema Diagram":"The following diagram illustrates the relationships between the main entities in Whisper's database:","core-tables#Core Tables":"","users-table#Users Table":"The users table stores essential information about Whisper users:\nCREATE TABLE users (\n  user_id UUID PRIMARY KEY,\n  username VARCHAR(64) NOT NULL UNIQUE,\n  email VARCHAR(255) NOT NULL UNIQUE,\n  display_name VARCHAR(128),\n  profile_picture_url TEXT,\n  status VARCHAR(64) DEFAULT 'offline',\n  last_seen TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\nCREATE INDEX idx_users_username ON users(username);\nCREATE INDEX idx_users_status ON users(status);","conversations-table#Conversations Table":"The conversations table represents chat conversations, which can be either direct (between two users) or groups:\nCREATE TABLE conversations (\n  conversation_id UUID PRIMARY KEY,\n  conversation_type VARCHAR(16) NOT NULL CHECK (conversation_type IN ('direct', 'group')),\n  title VARCHAR(128),\n  created_by UUID REFERENCES users(user_id),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\nCREATE INDEX idx_conversations_type ON conversations(conversation_type);\nCREATE INDEX idx_conversations_created_by ON conversations(created_by);","participants-table#Participants Table":"The participants table manages the relationship between users and conversations:\nCREATE TABLE participants (\n  participant_id UUID PRIMARY KEY,\n  user_id UUID NOT NULL REFERENCES users(user_id),\n  conversation_id UUID NOT NULL REFERENCES conversations(conversation_id),\n  role VARCHAR(16) DEFAULT 'member' CHECK (role IN ('admin', 'member')),\n  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  last_read_message_id UUID,\n  UNIQUE(user_id, conversation_id)\n);\nCREATE INDEX idx_participants_user ON participants(user_id);\nCREATE INDEX idx_participants_conversation ON participants(conversation_id);","messages-table#Messages Table":"The messages table stores all messages sent within the platform:\nCREATE TABLE messages (\n  message_id UUID PRIMARY KEY,\n  conversation_id UUID NOT NULL REFERENCES conversations(conversation_id),\n  sender_id UUID NOT NULL REFERENCES users(user_id),\n  message_type VARCHAR(16) NOT NULL CHECK (message_type IN ('text', 'media', 'system')),\n  content TEXT,\n  encrypted BOOLEAN DEFAULT TRUE,\n  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  edited_at TIMESTAMP WITH TIME ZONE,\n  parent_message_id UUID REFERENCES messages(message_id)\n);\nCREATE INDEX idx_messages_conversation ON messages(conversation_id);\nCREATE INDEX idx_messages_sender ON messages(sender_id);\nCREATE INDEX idx_messages_sent_at ON messages(sent_at);\nCREATE INDEX idx_messages_parent ON messages(parent_message_id);","media-table#Media Table":"The media table stores information about media files shared in messages:\nCREATE TABLE media (\n  media_id UUID PRIMARY KEY,\n  message_id UUID NOT NULL REFERENCES messages(message_id),\n  media_type VARCHAR(16) NOT NULL CHECK (media_type IN ('image', 'video', 'audio', 'document')),\n  file_name VARCHAR(255) NOT NULL,\n  file_size BIGINT NOT NULL,\n  mime_type VARCHAR(128) NOT NULL,\n  storage_path TEXT NOT NULL,\n  thumbnail_path TEXT,\n  metadata JSONB\n);\nCREATE INDEX idx_media_message ON media(message_id);\nCREATE INDEX idx_media_type ON media(media_type);","partitioning-strategy#Partitioning Strategy":"For high-scale deployments, Whisper implements table partitioning to improve query performance and maintenance operations:\nMessages are partitioned by date range (monthly), enabling efficient\narchiving and query optimization.\n-- Example of message table partitioning\nCREATE TABLE messages (\n  -- columns as defined above\n) PARTITION BY RANGE (sent_at);\n-- Create monthly partitions\nCREATE TABLE messages_y2023m01 PARTITION OF messages\n  FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\nCREATE TABLE messages_y2023m02 PARTITION OF messages\n  FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');\n-- Additional partitions as needed","indexing-strategy#Indexing Strategy":"Whisper employs a comprehensive indexing strategy to ensure optimal query performance:\nPrimary Key Indices: All tables have UUID primary keys\nForeign Key Indices: All foreign key columns are indexed\nCompound Indices: Created for frequently used query patterns\nPartial Indices: Used for filtering on common conditions\nGIN Indices: Used for JSONB and full-text search columns","data-access-patterns#Data Access Patterns":"The database design is optimized for these common data access patterns:\nAccess Pattern\tImplementation\tRetrieve recent messages\tIndex on (conversation_id, sent_at DESC)\tSearch message content\tFull-text search with GIN index\tUser conversation list\tJoin between users, participants, and conversations\tUnread message count\tComparison between last_read_message_id and latest message\tMedia gallery view\tIndex on (conversation_id, media_type)","backup-and-replication#Backup and Replication":"To ensure data durability and availability, Whisper employs:\nContinuous archiving with Point-in-Time Recovery (PITR)\nSynchronous replication to standby servers\nDaily full backups with 30-day retention\nCross-region backup storage","database-scaling#Database Scaling":"As user base grows, Whisper's database scales through:\nRead Replicas: For distributing read queries\nSharding: Horizontal partitioning by user geography or conversation ID\nConnection Pooling: Efficient management of database connections\nQuery Optimization: Regular query plan analysis and optimization\nCaching: Implementing Redis for frequently accessed data","redis#Redis":";"}},"/demo":{"title":"Whisper Chat Demo & Introduction","data":{"":"Whisper is currently in public beta. While the core functionality is stable,\nyou may encounter occasional issues as we continue to improve the platform.","what-is-whisper#What is Whisper?":"Whisper is a modern web-based chat application designed for secure, real-time communication. Built with privacy and performance as core principles, Whisper provides a seamless messaging experience across all devices.","core-features#Core Features":"","secure-communication#Secure Communication":"Whisper employs industry-standard encryption protocols to ensure that your messages remain private. All communications are encrypted end-to-end, meaning that only the intended recipients can read your messages.","real-time-messaging#Real-Time Messaging":"Experience seamless, real-time communication with instant message delivery, typing indicators, and read receipts. Whisper's architecture is optimized for low-latency communication, ensuring that your messages are delivered promptly.","multi-platform-support#Multi-Platform Support":"Whisper is available on all major platforms, including:\nWeb browsers (Chrome, Firefox, Safari, Edge)\niOS and Android mobile devices\nDesktop applications for Windows, macOS, and Linux","rich-media-sharing#Rich Media Sharing":"Share more than just text with Whisper's rich media support:\nImage and video sharing\nDocument attachments\nVoice messages\nLocation sharing\nCode snippets with syntax highlighting","group-conversations#Group Conversations":"Create group chats for team collaboration, family discussions, or social gatherings. Whisper supports:\nPublic and private groups\nRole-based permissions\nThread replies for organized discussions\nPinned messages for important information","technology-stack#Technology Stack":"Whisper is built on a modern technology stack designed for performance and scalability:\nFrontend: React, WebSocket API, WebRTC\nBackend: Node.js, Express, Socket.IO\nDatabase: PostgreSQL with real-time capabilities\nInfrastructure: Containerized microservices deployed on Kubernetes\nIn the following sections, we'll dive deeper into Whisper's architecture, exploring its protocol, sequence flows, database design, and performance characteristics.;"}},"/":{"title":"Whisper Chat Documentation","data":{"":"Whisper 是一款支持端到端加密的即时通讯应用，支持跨平台使用。","key-features#Key Features":"Whisper 是一款支持端到端加密的即时通讯应用，支持跨平台使用。\n用户注册/登录/登出\n私聊消息\n群聊消息\n用户在线状态展示\n高并发\n心跳机制\n消息撤回","getting-started#Getting Started":"Try the Whisper Demo to get a feel for how Whisper works."}},"/protocol/authentication":{"title":"用户认证与管理 (Authentication & User Management)","data":{"概述#概述":"本部分定义了用户注册、登录、登出的相关协议。TODO：后续需要添加和端到端加密更多相关的协议内容。","21-用户注册-user-registration#2.1. 用户注册 (User Registration)":"","register_request-client---server#REGISTER_REQUEST (Client -> Server)":"消息类型 ID: 101\nJSON type 字符串: \"REGISTER_REQUEST\"\n{\n    \"message_id\": \"c4a2b1e0-dbb8-4a94-83d3-c7d0b6a8f9c0\",\n    \"type\": \"REGISTER_REQUEST\",\n    \"timestamp\": \"2025-05-15T10:00:00Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"username\": \"newuser\",\n        \"password\": \"a_strong_password\",\n        \"identity_public_key\": \"base64_encoded_X25519_public_key_optional\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tusername\tstring\t否\t用户希望注册的用户名，服务器需校验唯一性。\t\"newuser\"\tpassword\tstring\t否\t用户设置的密码。注意: 客户端应通过 TLS 等安全通道发送。服务器负责安全地哈希和存储密码。\t\"a_strong_password\"\tidentity_public_key\tstring\t是\t用户可选提供的身份公钥 (例如 X25519), Base64 编码的字符串表示。\t\"base64_encoded_X25519_public_key_optional\"","register_response-server---client#REGISTER_RESPONSE (Server -> Client)":"消息类型 ID: 102\nJSON type 字符串: \"REGISTER_RESPONSE\"\n{\n    \"message_id\": \"s8f7e6d5-c4b3-2a10-9876-fedcba098765\",\n    \"type\": \"REGISTER_RESPONSE\",\n    \"timestamp\": \"2025-05-15T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c4a2b1e0-dbb8-4a94-83d3-c7d0b6a8f9c0\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Registration successful!\",\n        \"user_id\": \"usr_sj20djn2\",\n        \"ephemeral_public_key\": \"\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t注册是否成功。\ttrue\tmessage\tstring\t否\t注册结果的描述信息 (例如 \"Registration successful!\", \"Username already exists.\")\t\"Registration successful!\"\tuser_id\tstring\t是\t如果注册成功，服务器分配的唯一用户 ID。\t\"usr_sj20djn2\"\tephemeral_public_key\tstring\t是\t用户可选提供的当前会话临时公钥 (X25519 ek_pub), Base64 编码的字符串表示。\t\"\"","22-用户登录-user-login#2.2. 用户登录 (User Login)":"","login_request-client---server#LOGIN_REQUEST (Client -> Server)":"消息类型 ID: 103\nJSON type 字符串: \"LOGIN_REQUEST\"\n{\n    \"message_id\": \"c5b8c1f0-eac9-4b95-84d4-d8e1c7a9g0d1\",\n    \"type\": \"LOGIN_REQUEST\",\n    \"timestamp\": \"2025-05-15T10:05:00Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"username\": \"existinguser\",\n        \"password\": \"user_password\",\n        \"ephemeral_public_key\": \"\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tusername\tstring\t否\t登录用户名。\t\"existinguser\"\tpassword\tstring\t否\t用户密码。 (同样注意 TLS 安全传输)\t\"user_password\"\tephemeral_public_key\tstring\t是\t用户可选提供的当前会话临时公钥 (X25519 ek_pub), Base64 编码的字符串表示。\t\"\"","login_response-server---client#LOGIN_RESPONSE (Server -> Client)":"消息类型 ID: 104\nJSON type 字符串: \"LOGIN_RESPONSE\"\n{\n    \"message_id\": \"s9g7f6e5-d4c3-3b11-9877-gfeda0987654\",\n    \"type\": \"LOGIN_RESPONSE\",\n    \"timestamp\": \"2025-05-15T10:05:01Z\",\n    \"token\": \"a_new_valid_session_token_if_success\",\n    \"correlation_id\": \"c5b8c1f0-eac9-4b95-84d4-d8e1c7a9g0d1\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Login successful!\",\n        \"user_id\": \"usr_existing123\",\n        \"username\": \"existinguser\",\n        \"low_opk_count_warning\": false\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t登录是否成功。\ttrue\tmessage\tstring\t否\t登录结果的描述信息。\t\"Login successful!\"\tuser_id\tstring\t是\t如果登录成功，用户的唯一 ID。\t\"usr_existing123\"\tusername\tstring\t是\t如果登录成功，用户的用户名 (方便客户端确认)。\t\"existinguser\"\tlow_opk_count_warning\tboolean\t是\t如果为true，表示服务器检测到该用户在服务器上存储的一次性预共享密钥(OTPKey)数量偏低，客户端应尽快上传新的一批 OTPKey。\tfalse\t\n注意: 成功登录后，响应的顶层 token 字段将包含会话令牌。客户端后续请求需携带此令牌。","23-用户登出-user-logout#2.3. 用户登出 (User Logout)":"","logout_request-client---server#LOGOUT_REQUEST (Client -> Server)":"消息类型 ID: 105\nJSON type 字符串: \"LOGOUT_REQUEST\"\n{\n    \"message_id\": \"c6d9e2g1-fbd0-4c96-85e5-e9f2d8b0h1e2\",\n    \"type\": \"LOGOUT_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:00:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {}\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\t(空)\tN/A\tN/A\t登出请求的 payload 为空。\t{}","logout_response-server---client#LOGOUT_RESPONSE (Server -> Client)":"消息类型 ID: 106\nJSON type 字符串: \"LOGOUT_RESPONSE\"\n{\n    \"message_id\": \"sa0h8g7f-e5d4-4c12-9878-hgfedb098765\",\n    \"type\": \"LOGOUT_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c6d9e2g1-fbd0-4c96-85e5-e9f2d8b0h1e2\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Logout successful.\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t登出是否成功。\ttrue\tmessage\tstring\t否\t登出结果的描述信息。\t\"Logout successful.\""}},"/protocol":{"title":"Whisper Protocol Specification","data":{"":"This protocol documentation is intended for developers and system architects. For general usage information, please refer to the user guide.","protocol-overview#Protocol Overview":"Whisper utilizes a custom protocol built on top of WebSockets to enable secure, real-time communication between clients. The protocol is designed with the following goals in mind:\nSecurity: End-to-end encryption for all messages\nEfficiency: Minimal overhead for low-latency communication\nReliability: Message delivery guarantees with acknowledgments\nExtensibility: Flexible message format for future enhancements","message-format#Message Format":"All messages in the Whisper protocol follow a standardized JSON format:\n{\n    \"type\": \"message_type\",\n    \"id\": \"unique_message_id\",\n    \"timestamp\": 1634567890123,\n    \"sender\": \"user_id\",\n    \"recipient\": \"recipient_id\",\n    \"content\": {\n        // Message-specific payload\n    },\n    \"metadata\": {\n        // Additional message metadata\n    }\n}","message-types#Message Types":"The type field indicates the purpose of the message. Common message types include:\nType\tDescription\ttext\tStandard text message\tmedia\tMedia message (image, video, document)\ttyping\tTyping indicator\tread\tRead receipt\tpresence\tUser presence update\tsystem\tSystem notification","encryption#Encryption":"Whisper implements end-to-end encryption using the Signal Protocol, which provides:\nPerfect forward secrecy\nPost-compromise security\nDeniable authentication","undefined#Key Exchange Process":"Initial Registration:\nClient generates identity key pair (IK)\nClient generates signed pre-key (SPK) and signature\nClient generates one-time pre-keys (OPK)\nClient uploads public keys to server\nSession Establishment:\nInitiator fetches recipient's public keys\nInitiator generates ephemeral key pair\nInitiator computes shared secret using X3DH protocol\nInitiator sends initial message with key information","undefined#Message Encryption":"Whisper uses the Double Ratchet Algorithm for message encryption:\nRatchet Initialization:\nInitialize root key from key exchange\nDerive initial chain keys\nSending Messages:\nGenerate message key from sender chain\nEncrypt message with message key\nUpdate sender chain key\nReceiving Messages:\nDecrypt message with corresponding message key\nUpdate receiver chain key","undefined#Verification Mechanism":"Whisper provides multiple verification methods to ensure the authenticity of communications:\nSafety Numbers: Users can verify each other's identity by comparing safety numbers\nQR Code Verification: Scan a QR code to verify a contact's identity\nOut-of-Band Verification: Use an external secure channel to verify identity\nWhen a security event occurs (e.g., a contact reinstalls the app), users are notified about the change in safety numbers.","transport-layer#Transport Layer":"Whisper uses WebSockets as the primary transport layer, with HTTP long-polling as a fallback mechanism:\nWebSockets: Provides bi-directional, full-duplex communication channels over a single TCP connection\nHTTP Fallback: Used in environments where WebSockets are not supported or are blocked","message-flow#Message Flow":"Connection Establishment:\nClient connects to the Whisper server via WebSocket\nClient authenticates using JWT or similar token\nServer verifies authentication and establishes session\nMessage Sending:\nClient encrypts message using recipient's public key\nClient sends encrypted message to server\nServer validates message and forwards to recipient(s)\nRecipient acknowledges receipt\nServer confirms delivery to sender\nOffline Handling:\nIf recipient is offline, server stores message\nWhen recipient comes online, server delivers queued messages\nMessages expire after a configurable TTL (Time To Live)","rate-limiting-and-quotas#Rate Limiting and Quotas":"To prevent abuse and ensure fair usage, Whisper implements rate limiting and quotas:\nMaximum message rate: 100 messages per minute per user\nMaximum connections: 5 concurrent connections per user\nMessage size limit: 10MB for media, 4KB for text","api-reference#API Reference":"For detailed API documentation, please refer to the Whisper API Reference.","protocol-versioning#Protocol Versioning":"The Whisper protocol uses semantic versioning (MAJOR.MINOR.PATCH):\nCurrent version: 1.2.0\nBackward compatibility is maintained within the same MAJOR version\nClients should negotiate protocol version during connection establishment to ensure compatibility."}},"/protocol/group_chat":{"title":"群聊协议文档(Group Chat)","data":{"概述#概述":"TODO: 添加 MLS 加密方案的改进版\n注意：本文档中所有时间戳字段在 API 中以 ISO8601 格式字符串表示（如\"2025-05-30T09:00:00Z\"），但在实际代码实现中使用 datetime 对象进行处理。","51-群组管理-group-management#5.1. 群组管理 (Group Management)":"","511-创建群组-create-group#5.1.1. 创建群组 (Create Group)":"用户创建一个新的群组。\nCREATE_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"CREATE_GROUP_REQUEST\"\n消息类型数字 ID: 501\nJSON 示例:\n{\n    \"message_id\": \"create_grp_req_001\",\n    \"type\": \"CREATE_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T09:00:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_name\": \"Tech Discussion Group\",\n        \"group_description\": \"Share programming knowledge\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tgroup_description\tstring\t是\t群组描述 (可选)\t\"分享编程知识\"\t\nCREATE_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"CREATE_GROUP_RESPONSE\"\n消息类型数字 ID: 502\nJSON 示例 (成功):\n{\n    \"message_id\": \"create_grp_resp_001\",\n    \"type\": \"CREATE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"create_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Group created successfully\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Tech Discussion Group\",\n        \"group_description\": \"Share programming knowledge\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"create_grp_resp_002\",\n    \"type\": \"CREATE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"create_grp_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Group name already exists\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息 (例如 \"群组创建成功\")\t\"群组创建成功\"\tgroup_id\tstring\t是\t如果成功，返回新创建群组的唯一 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t如果成功，返回群组名称\t\"技术交流小组\"\tgroup_description\tstring\t是\t如果成功且提供，返回群组描述\t\"分享编程知识\"","512-更新群组信息-update-group-information#5.1.2. 更新群组信息 (Update Group Information)":"群组管理员更新群组的名称或描述。\nUPDATE_GROUP_INFO_REQUEST (Client -> Server)\n消息类型 ID (type string): \"UPDATE_GROUP_INFO_REQUEST\"\n消息类型数字 ID: 503\nJSON 示例:\n{\n    \"message_id\": \"update_grp_req_001\",\n    \"type\": \"UPDATE_GROUP_INFO_REQUEST\",\n    \"timestamp\": \"2025-05-30T09:30:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要更新的群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t新的群组名称 (如果更改)\t\"技术分享精英群\"\tgroup_description\tstring\t是\t新的群组描述 (如果更改)\t\"深入探讨前沿技术\"\t\nUPDATE_GROUP_INFO_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"UPDATE_GROUP_INFO_RESPONSE\"\n消息类型数字 ID: 504\nJSON 示例 (成功):\n{\n    \"message_id\": \"update_grp_resp_001\",\n    \"type\": \"UPDATE_GROUP_INFO_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:30:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"update_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Group information updated successfully\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"群组信息更新成功\"\tgroup_id\tstring\t是\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t更新后的群组名称 (如果成功且更改)\t\"技术分享精英群\"\tgroup_description\tstring\t是\t更新后的群组描述 (如果成功且更改)\t\"深入探讨前沿技术\"\t\nGROUP_INFO_UPDATED_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"GROUP_INFO_UPDATED_NOTIFICATION\"\n消息类型数字 ID: 505\nJSON 示例:\n{\n    \"message_id\": \"grp_info_updated_ntf_001\",\n    \"type\": \"GROUP_INFO_UPDATED_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T09:30:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"updated_by_user_id\": \"usr_admin_001\",\n        \"updated_by_username\": \"Admin John\",\n        \"new_group_name\": \"Advanced Tech Group\",\n        \"new_group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t被更新的群组 ID\t\"grp_uuid_123\"\tupdated_by_user_id\tstring\t否\t执行更新操作的用户 ID\t\"usr_admin_001\"\tupdated_by_username\tstring\t否\t执行更新操作的用户名\t\"管理员张三\"\tnew_group_name\tstring\t是\t更新后的群组名称 (如果更改)\t\"技术分享精英群\"\tnew_group_description\tstring\t是\t更新后的群组描述 (如果更改)\t\"深入探讨前沿技术\"","513-加入群组-join-group#5.1.3. 加入群组 (Join Group)":"用户请求加入一个群组。为简化，本协议假设服务器直接处理加入请求（例如，公开群组或服务器自动批准）。\nJOIN_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"JOIN_GROUP_REQUEST\"\n消息类型数字 ID: 506\nJSON 示例:\n{\n    \"message_id\": \"join_grp_req_001\",\n    \"type\": \"JOIN_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:00:00Z\",\n    \"token\": \"newbie_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要加入的群组 ID\t\"grp_uuid_123\"\t\nJOIN_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"JOIN_GROUP_RESPONSE\"\n消息类型数字 ID: 507\nJSON 示例 (成功):\n{\n    \"message_id\": \"join_grp_resp_001\",\n    \"type\": \"JOIN_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"join_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Successfully joined group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"成功加入群组\"\tgroup_id\tstring\t是\t群组 ID (如果成功)\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t群组名称 (如果成功)\t\"技术交流小组\"\t\nUSER_JOINED_GROUP_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"USER_JOINED_GROUP_NOTIFICATION\"\n消息类型数字 ID: 508\nJSON 示例:\n{\n    \"message_id\": \"user_joined_ntf_001\",\n    \"type\": \"USER_JOINED_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"joined_user_id\": \"usr_newbie_007\",\n        \"joined_username\": \"NewUser Mike\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t相关群组 ID\t\"grp_uuid_123\"\tjoined_user_id\tstring\t否\t加入用户的 ID\t\"usr_newbie_007\"\tjoined_username\tstring\t否\t加入用户的用户名\t\"新手小明\"","514-退出群组-leave-group#5.1.4. 退出群组 (Leave Group)":"用户主动退出一个群组。\nLEAVE_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"LEAVE_GROUP_REQUEST\"\n消息类型数字 ID: 509\nJSON 示例:\n{\n    \"message_id\": \"leave_grp_req_001\",\n    \"type\": \"LEAVE_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T11:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要退出的群组 ID\t\"grp_uuid_123\"\t\nLEAVE_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"LEAVE_GROUP_RESPONSE\"\n消息类型数字 ID: 510\nJSON 示例 (成功):\n{\n    \"message_id\": \"leave_grp_resp_001\",\n    \"type\": \"LEAVE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T11:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"leave_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Successfully left group\",\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"成功退出群组\"\tgroup_id\tstring\t是\t群组 ID (如果成功)\t\"grp_uuid_123\"\t\nUSER_LEFT_GROUP_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"USER_LEFT_GROUP_NOTIFICATION\"\n消息类型数字 ID: 511\nJSON 示例:\n{\n    \"message_id\": \"user_left_ntf_001\",\n    \"type\": \"USER_LEFT_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T11:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"left_user_id\": \"usr_oldbie_001\",\n        \"left_username\": \"Former User Bob\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t相关群组 ID\t\"grp_uuid_123\"\tleft_user_id\tstring\t否\t退出用户的 ID\t\"usr_oldbie_001\"\tleft_username\tstring\t否\t退出用户的用户名\t\"老王\"","515-获取群组列表-get-group-list#5.1.5. 获取群组列表 (Get Group List)":"客户端请求获取群组列表。如果提供用户 ID，则返回该用户加入的群组；否则返回服务器上的所有群组信息。\nGET_GROUPS_REQUEST (Client -> Server)\n消息类型 ID (type string): \"GET_GROUPS_REQUEST\"\n消息类型数字 ID: 518\nJSON 示例 (获取当前用户的群组):\n{\n    \"message_id\": \"get_groups_req_001\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {}\n}\nJSON 示例 (获取指定用户的群组):\n{\n    \"message_id\": \"get_groups_req_002\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"admin_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"user_id\": \"usr_target_001\"\n    }\n}\nJSON 示例 (获取所有群组):\n{\n    \"message_id\": \"get_groups_req_003\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"admin_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"get_all\": true\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tuser_id\tstring\t是\t指定用户 ID，获取该用户加入的群组列表\t\"usr_target_001\"\tget_all\tboolean\t是\t设为 true 时获取服务器上的所有群组\ttrue\t\nGET_GROUPS_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"GET_GROUPS_RESPONSE\"\n消息类型数字 ID: 519\nJSON 示例 (成功，有群组):\n{\n    \"message_id\": \"get_groups_resp_001\",\n    \"type\": \"GET_GROUPS_RESPONSE\",\n    \"timestamp\": \"2025-05-30T12:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"get_groups_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"groups\": [\n            {\n                \"group_id\": \"grp_uuid_123\",\n                \"group_name\": \"Advanced Tech Group\",\n                \"group_description\": \"Explore cutting-edge technology\",\n                \"last_message_snippet\": \"Hello everyone!\",\n                \"unread_count\": 2,\n                \"user_role\": null\n            },\n            {\n                \"group_id\": \"grp_uuid_456\",\n                \"group_name\": \"Product Discussion\",\n                \"group_description\": \"Discuss our products\",\n                \"last_message_snippet\": \"New feature discussion\",\n                \"unread_count\": 0,\n                \"user_role\": null\n            }\n        ]\n    }\n}\nJSON 示例 (成功，无群组):\n{\n    \"message_id\": \"get_groups_resp_002\",\n    \"type\": \"GET_GROUPS_RESPONSE\",\n    \"timestamp\": \"2025-05-30T12:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"get_groups_req_002\",\n    \"payload\": {\n        \"success\": true,\n        \"groups\": []\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tgroups\tArray[Object]\t是\t群组列表。如果为空则为空数组\t[{\"group_id\": \"grp_1\", \"group_name\": \"群组1\"}, {\"group_id\": \"grp_2\", \"group_name\": \"群组2\"}]\t\ngroups 数组中每个对象的结构:\n字段名\t类型\t可选\t描述\tgroup_id\tstring\t否\t群组的唯一 ID\tgroup_name\tstring\t否\t群组名称\tgroup_description\tstring\t是\t群组描述\tlast_message_snippet\tstring\t是\t最后一条消息摘要\tunread_count\tint\t是\t未读消息数（仅当查询特定用户时可用）\tuser_role\tenum\t是\t用户在群组中的角色，如果为 null 则表示用户不是群组成员","516-添加用户到群组-add-user-to-group#5.1.6. 添加用户到群组 (Add User to Group)":"群组管理员或具有相应权限的用户将另一用户添加到群组。\nADD_USER_TO_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"ADD_USER_TO_GROUP_REQUEST\"\n消息类型数字 ID: 520\nJSON 示例:\n{\n    \"message_id\": \"add_user_req_001\",\n    \"type\": \"ADD_USER_TO_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T14:00:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t目标群组的 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t要添加到群组的用户 ID\t\"usr_target_002\"\t\nADD_USER_TO_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"ADD_USER_TO_GROUP_RESPONSE\"\n消息类型数字 ID: 521\nJSON 示例 (成功):\n{\n    \"message_id\": \"add_user_resp_001\",\n    \"type\": \"ADD_USER_TO_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T14:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"add_user_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"User successfully added to group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"add_user_resp_002\",\n    \"type\": \"ADD_USER_TO_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T14:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"add_user_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Permission denied or user already in group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"用户成功添加到群组\"\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t被添加的用户 ID\t\"usr_target_002\"\t\nUSER_ADDED_TO_GROUP_NOTIFICATION (Server -> Group Members + Added User)\n消息类型 ID (type string): \"USER_ADDED_TO_GROUP_NOTIFICATION\"\n消息类型数字 ID: 522\nJSON 示例:\n{\n    \"message_id\": \"user_added_ntf_001\",\n    \"type\": \"USER_ADDED_TO_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T14:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"added_user_id\": \"usr_target_002\",\n        \"added_username\": \"New Member Alice\",\n        \"added_by_user_id\": \"usr_admin_001\",\n        \"added_by_username\": \"Admin John\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tadded_user_id\tstring\t否\t被添加用户的 ID\t\"usr_target_002\"\tadded_username\tstring\t否\t被添加用户的用户名\t\"新成员小爱\"\tadded_by_user_id\tstring\t否\t执行添加操作的用户 ID\t\"usr_admin_001\"\tadded_by_username\tstring\t否\t执行添加操作的用户名\t\"管理员张三\"","517-从群组移除用户-remove-user-from-group#5.1.7. 从群组移除用户 (Remove User from Group)":"群组管理员将用户从群组中移除。这与用户主动退出群组不同，因为它是由管理员或其他具有权限的用户发起的。\nREMOVE_USER_FROM_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"REMOVE_USER_FROM_GROUP_REQUEST\"\n消息类型数字 ID: 523\nJSON 示例:\n{\n    \"message_id\": \"remove_user_req_001\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T15:00:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\",\n        \"reason\": \"Violation of group rules\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t要移除的用户 ID\t\"usr_target_003\"\treason\tstring\t是\t移除用户的原因（可选）\t\"违反群组规则\"\t\nREMOVE_USER_FROM_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"REMOVE_USER_FROM_GROUP_RESPONSE\"\n消息类型数字 ID: 524\nJSON 示例 (成功):\n{\n    \"message_id\": \"remove_user_resp_001\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T15:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"remove_user_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"User successfully removed from group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"remove_user_resp_002\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T15:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"remove_user_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Permission denied or user not in group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"用户成功从群组移除\"\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t被移除的用户 ID\t\"usr_target_003\"\t\nUSER_REMOVED_FROM_GROUP_NOTIFICATION (Server -> Group Members + Removed User)\n消息类型 ID (type string): \"USER_REMOVED_FROM_GROUP_NOTIFICATION\"\n消息类型数字 ID: 525\nJSON 示例:\n{\n    \"message_id\": \"user_removed_ntf_001\",\n    \"type\": \"USER_REMOVED_FROM_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T15:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"removed_user_id\": \"usr_target_003\",\n        \"removed_username\": \"Former Member Dave\",\n        \"removed_by_user_id\": \"usr_admin_001\",\n        \"removed_by_username\": \"Admin John\",\n        \"reason\": \"Violation of group rules\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tremoved_user_id\tstring\t否\t被移除用户的 ID\t\"usr_target_003\"\tremoved_username\tstring\t否\t被移除用户的用户名\t\"前成员小王\"\tremoved_by_user_id\tstring\t否\t执行移除操作的用户 ID\t\"usr_admin_001\"\tremoved_by_username\tstring\t否\t执行移除操作的用户名\t\"管理员张三\"\treason\tstring\t是\t移除用户的原因（可选）\t\"违反群组规则\"","52-消息收发-message-handling#5.2. 消息收发 (Message Handling)":"","521-发送群聊消息-send-group-chat-message#5.2.1. 发送群聊消息 (Send Group Chat Message)":"用户向指定群组发送一条文本消息。\nSEND_GROUP_CHAT_MESSAGE_REQUEST (Client -> Server)\n消息类型 ID (type string): \"SEND_GROUP_CHAT_MESSAGE_REQUEST\"\n消息类型数字 ID: 512\nJSON 示例:\n{\n    \"message_id\": \"send_grp_msg_req_001\",\n    \"type\": \"SEND_GROUP_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"content\": \"Hello everyone!\",\n        \"client_message_id\": \"client_msg_abc\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t目标群组的 ID\t\"grp_uuid_123\"\tcontent\tstring\t否\t消息的文本内容\t\"大家好！\"\tclient_message_id\tstring\t否\t客户端生成的消息唯一 ID (用于追踪和去重)\t\"client_msg_abc\"\t\nSEND_GROUP_CHAT_MESSAGE_ACK (Server -> Client, to Sender)\n消息类型 ID (type string): \"SEND_GROUP_CHAT_MESSAGE_ACK\"\n消息类型数字 ID: 513\nJSON 示例:\n{\n    \"message_id\": \"send_grp_msg_ack_001\",\n    \"type\": \"SEND_GROUP_CHAT_MESSAGE_ACK\",\n    \"timestamp\": \"2025-05-30T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"send_grp_msg_req_001\",\n    \"payload\": {\n        \"status_message\": \"Message received\",\n        \"server_message_id\": \"server_msg_xyz\",\n        \"client_message_id\": \"client_msg_abc\",\n        \"message_server_timestamp\": \"2025-05-30T10:00:01Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tstatus_message\tstring\t否\t服务器处理状态 (例如 \"消息已接收\")\t\"消息已接收\"\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID\t\"server_msg_xyz\"\tclient_message_id\tstring\t否\t回显客户端提供的 client_message_id\t\"client_msg_abc\"\tmessage_server_timestamp\tstring\t否\t消息在服务器被处理和存储的时间戳 (ISO8601)\t\"2025-05-30T10:00:01Z\"","522-接收群聊消息-receive-group-message#5.2.2. 接收群聊消息 (Receive Group Message)":"服务器将群聊消息广播给群组内的所有在线成员（通常不包括发送者自己，发送者通过 ACK 和本地 UI 更新）。\nRECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION (Server -> Client, to Group Members)\n消息类型 ID (type string): \"RECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION\"\n消息类型数字 ID: 514\nJSON 示例:\n{\n    \"message_id\": \"recv_grp_msg_ntf_001\",\n    \"type\": \"RECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"server_message_id\": \"server_msg_xyz\",\n        \"sender_user_id\": \"usr_sender_001\",\n        \"sender_username\": \"Sender John\",\n        \"content\": \"Hello everyone!\",\n        \"message_timestamp\": \"2025-05-30T10:00:01Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所属群组的 ID\t\"grp_uuid_123\"\tserver_message_id\tstring\t否\t服务器生成的消息唯一 ID\t\"server_msg_xyz\"\tsender_user_id\tstring\t否\t消息发送者的用户 ID\t\"usr_sender_001\"\tsender_username\tstring\t否\t消息发送者的用户名\t\"发送者小张\"\tcontent\tstring\t否\t消息的文本内容\t\"大家好！\"\tmessage_timestamp\tstring\t否\t消息在服务器的权威时间戳 (ISO8601)\t\"2025-05-30T10:00:01Z\"","523-撤回群聊消息-recall-group-chat-message#5.2.3. 撤回群聊消息 (Recall Group Chat Message)":"消息发送者请求撤回一条已发送的消息。服务器记录撤回状态并通知群成员。\nRECALL_GROUP_CHAT_MESSAGE_REQUEST (Client -> Server)\n消息类型 ID (type string): \"RECALL_GROUP_CHAT_MESSAGE_REQUEST\"\n消息类型数字 ID: 515\nJSON 示例:\n{\n    \"message_id\": \"recall_grp_msg_req_001\",\n    \"type\": \"RECALL_GROUP_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:05:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"server_message_id_to_recall\": \"server_msg_xyz\",\n        \"client_recall_request_id\": \"client_recall_req_789\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所在群组的 ID\t\"grp_uuid_123\"\tserver_message_id_to_recall\tstring\t否\t要撤回的消息的 server_message_id\t\"server_msg_xyz\"\tclient_recall_request_id\tstring\t是\t客户端生成的撤回请求 ID (用于追踪)\t\"client_recall_req_789\"\t\nGROUP_CHAT_MESSAGE_RECALLED_ACK (Server -> Client, to Sender of recall request)\n消息类型 ID (type string): \"GROUP_CHAT_MESSAGE_RECALLED_ACK\"\n消息类型数字 ID: 516\nJSON 示例 (成功):\n{\n    \"message_id\": \"recall_grp_msg_ack_001\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-30T10:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"recall_grp_msg_req_001\",\n    \"payload\": {\n        \"status_code\": 200,\n        \"status_message\": \"Message recalled successfully\",\n        \"recalled_server_message_id\": \"server_msg_xyz\",\n        \"client_recall_request_id\": \"client_recall_req_789\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"recall_grp_msg_ack_002\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-30T10:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"recall_grp_msg_req_002\",\n    \"payload\": {\n        \"status_code\": 404,\n        \"status_message\": \"Message not found or already recalled\",\n        \"recalled_server_message_id\": \"server_msg_nonexist\",\n        \"client_recall_request_id\": \"client_recall_req_999\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tstatus_code\tint\t否\t撤回操作状态码 (例如 200 成功, 403 禁止, 404 未找到, 410 超时/窗口过期)\t200\tstatus_message\tstring\t否\t描述撤回操作结果的消息\t\"消息撤回成功\"\trecalled_server_message_id\tstring\t否\t被尝试撤回的消息的 server_message_id\t\"server_msg_xyz\"\tclient_recall_request_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显\t\"client_recall_req_789\"\t\nGROUP_CHAT_MESSAGE_RECALL_NOTIFICATION (Server -> Client, to Group Members)\n消息类型 ID (type string): \"GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION\"\n消息类型数字 ID: 517\nJSON 示例:\n{\n    \"message_id\": \"grp_msg_recalled_ntf_001\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:05:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"recalled_server_message_id\": \"server_msg_xyz\",\n        \"recalled_by_user_id\": \"usr_sender_001\",\n        \"recall_timestamp\": \"2025-05-30T10:05:00Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所在群组的 ID\t\"grp_uuid_123\"\trecalled_server_message_id\tstring\t否\t被撤回消息的 server_message_id\t\"server_msg_xyz\"\trecalled_by_user_id\tstring\t否\t发起撤回操作的用户的 ID (即原消息发送者)\t\"usr_sender_001\"\trecall_timestamp\tstring\t否\t服务器处理撤回操作的时间戳 (ISO8601)\t\"2025-05-30T10:05:00Z\"\t\n客户端处理撤回通知的建议: 客户端在收到 GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION 后，应在其本地消息列表中找到对应的 recalled_server_message_id 的消息，并将其标记为\"已撤回\"或替换为提示信息 (例如 \"[发送者] 撤回了一条消息\")，而不是直接删除，以保持对话上下文的连贯性。","数据结构定义#数据结构定义":"","groupuserrole#GroupUserRole":"用户在群组中的角色枚举，定义了用户在群组中的权限级别。\n枚举值\t描述\tOWNER\t群主，拥有所有权限，包括解散群组\tADMIN\t管理员，拥有管理成员和修改群信息的权限\tMEMBER\t普通成员，只有基本的发言和查看权限"}},"/protocol/presence":{"title":"在线状态与心跳 (Presence & Heartbeat)","data":{"概述#概述":"本部分定义了用户在线状态管理和心跳检测机制。这些功能对于维护实时通信状态和确保连接活跃性至关重要。用户状态枚举值：协议支持以下用户状态值（对应代码中的 UserStatus 枚举）：\n\"ONLINE\" - 用户在线且活跃\n\"OFFLINE\" - 用户离线\n\"UNKNOWN\" - 用户状态未知 (例如，尝试查询的用户不存在于数据库中时，作为一种可能的标记，但更推荐使用标准的 ERROR_RESPONSE 来指示用户未找到)\n\"AWAY\" - 用户暂时离开\n\"BUSY\" - 用户忙碌中\n\"INVISIBLE\" - 用户隐身模式\n\"PENDING\" - 用户状态待定\n\"BANNED\" - 用户被禁止","51-心跳-heartbeat#5.1. 心跳 (Heartbeat)":"","heartbeat_request-client---server#HEARTBEAT_REQUEST (Client -> Server)":"消息类型 ID: 401\nJSON type 字符串: \"HEARTBEAT_REQUEST\"\nJSON 示例:\n{\n    \"message_id\": \"cb2i4k7m-lgk5-6h01-80j0-j4k7i3g5m6j7\",\n    \"type\": \"HEARTBEAT_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:20:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"client_timestamp\": \"2025-05-15T11:19:59Z\"\n    }\n}\nPayload (对应 HeartbeatRequestPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tclient_timestamp\tstring (ISO8601)\t否\t客户端发送心跳时的本地时间。Pydantic 模型中为 datetime 类型。\t\"2025-05-15T11:19:59Z\"","heartbeat_response-server---client#HEARTBEAT_RESPONSE (Server -> Client)":"消息类型 ID: 402\nJSON type 字符串: \"HEARTBEAT_RESPONSE\"\nJSON 示例:\n{\n    \"message_id\": \"sh7o5n4m-m2k1-1j19-9875-onmlkjihgfed\",\n    \"type\": \"HEARTBEAT_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:20:00Z\",\n    \"token\": null,\n    \"correlation_id\": \"cb2i4k7m-lgk5-6h01-80j0-j4k7i3g5m6j7\",\n    \"payload\": {\n        \"server_timestamp\": \"2025-05-15T11:20:00Z\"\n    }\n}\nPayload (对应 HeartbeatResponsePayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tserver_timestamp\tstring (ISO8601)\t否\t服务器当前时间。Pydantic 模型中为 datetime 类型。\t\"2025-05-15T11:20:00Z\"\t\n注意: HEARTBEAT_RESPONSE 是可选实现。如果客户端需要确认心跳被服务器接收，服务器应发送此响应。","52-用户状态更新-user-status-update#5.2. 用户状态更新 (User Status Update)":"","user_status_update_notification-server---client-to-relevant-clients#USER_STATUS_UPDATE_NOTIFICATION (Server -> Client, to relevant Clients)":"消息类型 ID: 403\nJSON type 字符串: \"USER_STATUS_UPDATE_NOTIFICATION\"\nJSON 示例:\n{\n    \"message_id\": \"si8p6o5n-n3l2-2k20-9876-ponmlkjihgfe\",\n    \"type\": \"USER_STATUS_UPDATE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"content\": {\n            \"user_id\": \"usr_friend456\",\n            \"username\": \"FriendUser\",\n            \"status\": \"ONLINE\",\n            \"last_seen\": null\n        }\n    }\n}\nPayload (对应 UserStatusUpdateNotificationPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tcontent\tUserStatusInfo\t否\t包含完整用户状态信息的对象。详见下方 UserStatusInfo 结构定义。","53-查询用户状态-query-user-status#5.3. 查询用户状态 (Query User Status)":"","query_user_status_request-client---server#QUERY_USER_STATUS_REQUEST (Client -> Server)":"消息类型 ID: 404\nJSON type 字符串: \"QUERY_USER_STATUS_REQUEST\"\nJSON 示例:\n{\n    \"message_id\": \"sj9q7p6o-o4n3-3l21-9877-qponmlkjihgf\",\n    \"type\": \"QUERY_USER_STATUS_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:06:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"target_user_ids\": [\"usr_friend456\", \"usr_friend789\"]\n    }\n}\nPayload (对应 QueryUserStatusRequestPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\ttarget_user_ids\tList[string]\t是 (Pydantic 模型中 default=[], 实际发送时可为空列表)\t要查询状态的用户 ID 列表。如果为空列表或 null (根据服务器实现处理 None 的方式)，服务器返回所有当前在线用户的状态信息。\t[\"usr_friend456\", \"usr_friend789\"]\t\n特殊行为：在线用户发现当 target_user_ids 为空列表 (或 null, 取决于服务器如何处理该字段的缺失或 None 值) 时，服务器返回所有当前在线用户的状态信息。这解决了新用户登录时的\"鸡生蛋、蛋生鸡\"问题：\n新用户登录后不知道有哪些用户在线。\n发送空的 target_user_ids 列表可以发现所有在线用户。\n之后可以通过状态更新通知保持同步。","query_user_status_response-server---client#QUERY_USER_STATUS_RESPONSE (Server -> Client)":"消息类型 ID: 405\nJSON type 字符串: \"QUERY_USER_STATUS_RESPONSE\"\nJSON 示例:\n{\n    \"message_id\": \"sk0s8r7q-p5o4-4n22-9878-srqponmlkjih\",\n    \"type\": \"QUERY_USER_STATUS_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:06:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"sj9q7p6o-o4n3-3l21-9877-qponmlkjihgf\",\n    \"payload\": {\n        \"results\": [\n            {\n                \"user_id\": \"usr_friend456\",\n                \"username\": \"FriendUser\",\n                \"status\": \"ONLINE\",\n                \"last_seen\": null\n            },\n            {\n                \"user_id\": \"usr_friend789\",\n                \"username\": \"AnotherFriend\",\n                \"status\": \"OFFLINE\",\n                \"last_seen\": \"2025-05-15T10:30:00Z\"\n            }\n        ]\n    }\n}\nPayload (对应 QueryUserStatusResponsePayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tresults\tList[UserStatusInfo]\t否\t查询结果列表，包含每个用户的完整 UserStatusInfo 对象。","数据结构定义#数据结构定义":"","userstatusinfo#UserStatusInfo":"用户状态信息的完整结构 (对应 UserStatusInfo Pydantic 模型)：\n参数名\t类型\tOptional?\t描述\t示例\tuser_id\tstring (Pydantic: UserId)\t否\t用户的唯一 ID。\t\"usr_friend456\"\tusername\tstring\t否\t用户名。\t\"FriendUser\"\tstatus\tstring (Pydantic: UserStatus enum)\t否\t用户当前状态，使用上述枚举值之一。\t\"ONLINE\"\tlast_seen\tstring (ISO8601) (Pydantic: Optional[datetime])\t是\t用户最后活跃时间。根据你的定义，在线时可为 null，离线时提供时间戳。\t\"2025-05-15T10:30:00Z\" or null"}},"/protocol/private_chat":{"title":"一对一聊天 (Private Chat)","data":{"概述#概述":"本部分定义了支持双模式的一对一私聊消息系统：\n端到端加密 (E2EE)模式：基于 Signal 协议，使用预共享密钥(PreKey)机制建立初始会话，然后使用双棘轮(Double Ratchet)算法进行后续消息加密。\n明文模式：直接传输未经加密的文本消息，用于简化实现或特定非敏感场景。\n客户端在发送消息时，将通过 MessageContent 对象中的 type 字段指明所使用的模式。服务器主要负责透明转发消息内容。\n注意：本文档中所有时间戳字段在 API 中以 ISO8601 格式字符串表示（如\"2025-05-15T11:05:00Z\"），但在实际代码实现中使用 datetime 对象进行处理。","31-发送私聊消息-send-private-message#3.1. 发送私聊消息 (Send Private Message)":"","send_private_chat_message_request-client---server#SEND_PRIVATE_CHAT_MESSAGE_REQUEST (Client -> Server)":"消息类型 ID: 201\nJSON type 字符串: \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\"\nJSON 示例 (E2EE - PreKey 消息):\n{\n    \"message_id\": \"c7e0f3h2-gcd1-4d97-86f6-f0g3e9c1i2f3\",\n    \"type\": \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:05:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend456\",\n        \"content\": {\n            \"type\": \"prekey\",\n            \"body\": \"U29tZSBFbmNyeXB0ZWQgRGF0YQ==\",\n            \"sender_identity_public_key\": \"base64_sender_IK_pub\",\n            \"sender_ephemeral_public_key\": \"base64_sender_EK_pub\",\n            \"recipient_signed_pre_key_id\": 123456,\n            \"recipient_one_time_pre_key_id\": 123457\n        },\n        \"client_message_id\": \"client_msg_uuid_001\"\n    }\n}\nJSON 示例 (明文消息):\n{\n    \"message_id\": \"p9a8b7c6-d5e4-f3g2-h1i0-j9k8l7m6n5o4\",\n    \"type\": \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:07:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend789\",\n        \"content\": {\n            \"type\": \"plaintext\",\n            \"body\": \"你好，这是一条明文消息！\"\n        },\n        \"client_message_id\": \"client_msg_uuid_002\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\trecipient_user_id\tstring\t否\t消息接收者的用户 ID。\t\"usr_friend456\"\tcontent\tMessageContent\t否\t消息内容对象。其具体结构和字段取决于 content.type 的值。详见下方 MessageContent 定义。\t{...}\tclient_message_id\tstring\t是\t客户端生成的消息 ID，用于追踪消息发送状态。服务端在 ACK 中会回显此 ID。\t\"client_msg_uuid_001\"","private_chat_message_sent_ack-server---client-to-sender#PRIVATE_CHAT_MESSAGE_SENT_ACK (Server -> Client, to Sender)":"消息类型 ID: 202 (通用于私聊和群聊消息发送确认)\nJSON type 字符串: \"PRIVATE_CHAT_MESSAGE_SENT_ACK\"\n此消息结构保持不变，因为它只确认服务器已处理消息，不关心内容是明文还是密文。JSON 示例:\n{\n    \"message_id\": \"sb1i9h8g-f6e5-5d13-9879-ihgfedb09876\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_SENT_ACK\",\n    \"timestamp\": \"2025-05-15T11:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c7e0f3h2-gcd1-4d97-86f6-f0g3e9c1i2f3\",\n    \"payload\": {\n        \"status_message\": \"Message processed by server.\",\n        \"server_message_id\": \"srv_msg_xyz789\",\n        \"client_message_id\": \"client_msg_uuid_001\",\n        \"message_timestamp\": \"2025-05-15T11:05:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tstatus_message\tstring\t否\t消息处理状态 (例如 \"Message processed by server\", \"Recipient offline, message stored\").\t\"Message processed by server.\"\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID。\t\"srv_msg_xyz789\"\tclient_message_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显。\t\"client_msg_uuid_001\"\tmessage_timestamp\tstring (ISO8601)\t否\t消息在服务端被处理并分配 server_message_id 时的精确时间戳。客户端应使用此时间戳更新本地消息记录。\t\"2025-05-15T11:05:00Z\"","32-接收私聊消息-receive-private-message#3.2. 接收私聊消息 (Receive Private Message)":"","receive_private_chat_message_notification-server---client-to-recipient#RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION (Server -> Client, to Recipient)":"消息类型 ID: 203\nJSON type 字符串: \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\"\n服务器将 SEND_PRIVATE_CHAT_MESSAGE_REQUEST 中的 content 对象原样转发给接收方。JSON 示例 (E2EE - PreKey 消息):\n{\n    \"message_id\": \"sc2j0i9h-g7f6-6e14-9870-jihgfedb0987\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:05:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id\": \"srv_msg_xyz789\",\n        \"sender_user_id\": \"usr_sender123\",\n        \"sender_username\": \"SenderName\",\n        \"content\": {\n            \"type\": \"prekey\",\n            \"body\": \"U29tZSBFbmNyeXB0ZWQgRGF0YQ==\",\n            \"sender_identity_public_key\": \"base64_sender_IK_pub\",\n            \"sender_ephemeral_public_key\": \"base64_sender_EK_pub\",\n            \"recipient_signed_pre_key_id\": 123456,\n            \"recipient_one_time_pre_key_id\": 123457\n        },\n        \"message_timestamp\": \"2025-05-15T11:05:00Z\"\n    }\n}\nJSON 示例 (明文消息):\n{\n    \"message_id\": \"rd3k1j0i-h8g7-7f15-9871-kjihgfedcba0\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:07:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id\": \"srv_msg_abc123\",\n        \"sender_user_id\": \"usr_another_sender\",\n        \"sender_username\": \"AnotherSenderName\",\n        \"content\": {\n            \"type\": \"plaintext\",\n            \"body\": \"你好，这是一条来自服务器转发的明文消息！\"\n        },\n        \"message_timestamp\": \"2025-05-15T11:07:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID。\t\"srv_msg_xyz789\"\tsender_user_id\tstring\t否\t消息发送者的用户 ID。\t\"usr_sender123\"\tsender_username\tstring\t否\t消息发送者的用户名。\t\"SenderName\"\tcontent\tMessageContent\t否\t消息内容对象。接收方客户端根据其内部的 type 字段进行相应处理。详见 MessageContent 定义。\t{...}\tmessage_timestamp\tstring (ISO8601)\t否\t消息的原始发送时间戳（即发送方客户端创建消息时的时间戳）。\t\"2025-05-15T11:05:00Z\"\t\n好的，我们将在您现有的一对一聊天协议基础上添加撤回消息的功能。核心思路是：\n发送方 发起一个撤回请求，指明要撤回的服务器消息 ID (server_message_id)。\n服务器 验证请求（例如，是否是消息的原始发送者，是否在允许的时间窗口内——如果需要定义时间窗口的话），然后通知接收方该消息已被撤回。\n接收方客户端 收到撤回通知后，在其本地将对应消息标记为已撤回或直接移除。\n服务器也会给发送方一个撤回操作的确认。\n由于端到端加密 (E2EE) 的特性，服务器无法读取消息内容，也无法\"删除\"已发送到接收方设备并可能已被解密的消息内容。撤回操作本质上是发送一个\"指令\"，告知接收方客户端\"请将 ID 为 X 的消息视为已撤回\"。接收方客户端负责执行此操作。以下是协议的补充部分：","33-撤回私聊消息-recall-private-message#3.3. 撤回私聊消息 (Recall Private Message)":"本节定义了用户撤回已发送私聊消息的机制。撤回操作针对的是 server_message_id。","331-recall_private_chat_message_request-client---server-from-sender#3.3.1. RECALL_PRIVATE_CHAT_MESSAGE_REQUEST (Client -> Server, from Sender)":"消息类型 ID: 204\nJSON type 字符串: \"RECALL_PRIVATE_CHAT_MESSAGE_REQUEST\"\n当用户希望撤回一条已发送的消息时，客户端向服务器发送此请求。JSON 示例:\n{\n    \"message_id\": \"r3c4ll_req_uuid_001\",\n    \"type\": \"RECALL_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:10:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend456\",\n        \"server_message_id_to_recall\": \"srv_msg_xyz789\",\n        \"client_recall_request_id\": \"client_recall_uuid_001\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\trecipient_user_id\tstring\t否\t原始消息接收者的用户 ID (即与谁的聊天会话中的消息)。\t\"usr_friend456\"\tserver_message_id_to_recall\tstring\t否\t需要被撤回的消息在服务器端生成的唯一 ID (server_message_id)。\t\"srv_msg_xyz789\"\tclient_recall_request_id\tstring\t是\t客户端生成的撤回请求 ID，用于追踪撤回请求的状态。服务端在 ACK 中会回显此 ID。\t\"client_recall_uuid_001\"","332-private_chat_message_recalled_ack-server---client-to-sender#3.3.2. PRIVATE_CHAT_MESSAGE_RECALLED_ACK (Server -> Client, to Sender)":"消息类型 ID: 205\nJSON type 字符串: \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\"\n服务器在处理完撤回请求后，向发起撤回的客户端发送此确认消息。JSON 示例 (成功):\n{\n    \"message_id\": \"ack_recall_srv_uuid_002\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-15T11:10:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"r3c4ll_req_uuid_001\",\n    \"payload\": {\n        \"status\": true,\n        \"status_message\": \"Message recall request processed successfully.\",\n        \"recalled_server_message_id\": \"srv_msg_xyz789\",\n        \"client_recall_request_id\": \"client_recall_uuid_001\"\n    }\n}\nJSON 示例 (失败 - 例如消息不存在或超时):\n{\n    \"message_id\": \"ack_recall_srv_uuid_003\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-15T11:10:02Z\",\n    \"token\": null,\n    \"correlation_id\": \"r3c4ll_req_uuid_002\",\n    \"payload\": {\n        \"status\": false,\n        \"status_message\": \"Message not found or recall window expired.\",\n        \"recalled_server_message_id\": \"srv_msg_nonexistent123\",\n        \"client_recall_request_id\": \"client_recall_uuid_002\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tstatus\tbool\t否\t撤回操作是否成功\ttrue\tstatus_message\tstring\t否\t描述撤回操作结果的消息。\t\"Message recall request processed successfully.\"\trecalled_server_message_id\tstring\t否\t被尝试撤回的消息的 server_message_id。\t\"srv_msg_xyz789\"\tclient_recall_request_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显。\t\"client_recall_uuid_001\"","333-receive_private_chat_message_recall_notification-server---client-to-recipient#3.3.3. RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION (Server -> Client, to Recipient)":"消息类型 ID: 206\nJSON type 字符串: \"RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION\"\n当一条消息被发送者撤回后，服务器向该消息的接收方发送此通知。JSON 示例:\n{\n    \"message_id\": \"ntf_recall_srv_uuid_004\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:10:03Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id_to_recall\": \"srv_msg_xyz789\",\n        \"recalled_by_user_id\": \"usr_sender123\",\n        \"chat_partner_user_id\": \"usr_sender123\",\n        \"recall_timestamp\": \"2025-05-15T11:10:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tserver_message_id_to_recall\tstring\t否\t被撤回的消息的 server_message_id。接收方客户端根据此 ID 找到并处理本地消息。\t\"srv_msg_xyz789\"\trecalled_by_user_id\tstring\t否\t发起撤回操作的用户 ID (即原始消息的发送者)。\t\"usr_sender123\"\tchat_partner_user_id\tstring\t否\t对于接收方而言，这是其聊天对象的 ID，即消息的发送者。\t\"usr_sender123\"\trecall_timestamp\tstring (ISO8601)\t否\t撤回操作发生的原始时间戳（即发送方客户端发起撤回请求的时间）。\t\"2025-05-15T11:10:00Z\"","撤回消息处理规则-message-recall-handling-rules#撤回消息处理规则 (Message Recall Handling Rules)":"","服务器处理规则#服务器处理规则:":"验证请求:\n验证 token 的有效性。\n验证发起撤回请求的用户是否是 server_message_id_to_recall 对应消息的原始发送者。\n(可选) 检查消息是否在允许的撤回时间窗口内（例如，发送后的 X 分钟内）。如果超出时间窗口，可以拒绝撤回。\n检查消息是否存在且尚未被撤回。\n处理撤回:\n如果验证通过，服务器应记录该消息已被撤回（例如，在数据库中标记）。这可以防止将来再次尝试传递该消息（如果它之前因接收方离线而未送达）。\n向发起撤回的客户端发送 PRIVATE_CHAT_MESSAGE_RECALLED_ACK。\n向消息的接收方客户端（recipient_user_id）发送 RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION。如果接收方当前不在线，则在其下次上线时发送此通知，类似于离线消息推送。\nE2EE 消息: 对于 E2EE 消息，服务器无法访问或修改消息内容。撤回操作仅针对消息的元数据和传递状态。服务器的角色是通知相关客户端发生了撤回事件。\n明文消息: 对于明文消息，服务器理论上可以从其存储中删除消息体（如果它有存储的话），但主要目的仍然是通知客户端。","客户端处理规则-发送方#客户端处理规则 (发送方):":"发起撤回: 用户选择撤回某条已发送的消息。客户端应使用该消息的 server_message_id (在 PRIVATE_CHAT_MESSAGE_SENT_ACK 中获得) 来构建 RECALL_PRIVATE_CHAT_MESSAGE_REQUEST。\n处理确认:\n收到 PRIVATE_CHAT_MESSAGE_RECALLED_ACK 后，根据 status 更新本地 UI。\n如果成功，可以在本地将对应消息标记为\"已撤回\"或更新其显示状态。\n如果失败 (例如超时、消息已被对方读取且服务器策略不允许再撤回等)，则向用户显示相应的错误信息。","客户端处理规则-接收方#客户端处理规则 (接收方):":"接收撤回通知: 收到 RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION。\n处理消息:\n根据 payload.server_message_id_to_recall 找到本地存储的对应消息。\n将该消息标记为\"已撤回\"。UI 上通常会显示类似\"此消息已被撤回\"的提示，而不是直接删除，以免造成对话上下文的困惑。\n重要: 如果消息是 E2EE 并且已被解密并存储在本地，客户端应确保该解密后的内容不再对用户可见。具体实现可以是删除解密内容，或用占位符替换。\n如果收到针对一条不存在的 server_message_id 的撤回通知（例如，由于网络延迟或状态不同步，消息在撤回通知到达前已被本地删除），客户端应静默忽略或记录一个低优先级的日志。","对-e2ee-模式的影响#对 E2EE 模式的影响:":"撤回功能不破坏 E2EE 的安全性。服务器仍然不知道消息内容。\n撤回的\"效力\"依赖于接收方客户端的正确实现。如果接收方客户端被篡改或不遵守协议，它可能不会隐藏已接收和解密的消息。\n一旦消息在接收端被解密并显示，撤回操作无法保证消息内容完全从接收者的视野或记忆中消失，它主要是在应用层面移除消息的展示。","数据结构定义#数据结构定义":"","messagecontent#MessageContent":"用于承载消息内容，支持明文、Signal PreKey 和 Signal Ratchet 三种类型。\n参数名\t类型\ttype 条件\t描述\t示例\ttype\tstring (enum)\t(所有类型共有)\t消息内容类型。必须是以下之一：\"plaintext\", \"prekey\", \"ratchet\"。\t\"prekey\"\tbody\tstring\t(所有类型共有)\t消息主体。如果 type 为 \"plaintext\"，则为 UTF-8 明文字符串；如果为 \"prekey\" 或 \"ratchet\"，则为 Base64 编码的密文字符串。\t\"Hello!\" 或 \"U29tZSBFbmN...\"\tsender_identity_public_key\tstring\t\"prekey\"\t仅当type为\"prekey\"时出现。 发送者的身份公钥 (IK_pub), Base64 编码。\t\"base64_sender_IK_pub\"\tsender_ephemeral_public_key\tstring\t\"prekey\"\t仅当type为\"prekey\"时出现。 发送者此次消息/会话的临时公钥 (EK_pub), Base64 编码。\t\"base64_sender_EK_pub\"\trecipient_signed_pre_key_id\tint\t\"prekey\"\t仅当type为\"prekey\"时出现。 接收方被使用的签名预共享密钥(SPK)的 ID。\t123456\trecipient_one_time_pre_key_id\tint\t\"prekey\" (可选)\t仅当type为\"prekey\"时出现。 接收方被使用的一次性预共享密钥(OPK)的 ID (如果 OPK 被使用)。\t123457\tratchet_header\tRatchetHeader\t\"ratchet\"\t仅当type为\"ratchet\"时出现。 包含双棘轮算法所需头部信息。如果type不为\"ratchet\"，此字段应为null或不存在。\t{...} (参见 RatchetHeader 定义)","ratchetheader#RatchetHeader":"用于双棘轮消息的头部信息（此结构保持不变）。\n参数名\t类型\tOptional?\t描述\tsender_ratchet_public_key\tstring\t否\t发送方当前棘轮公钥 (例如 X25519 的公钥)，Base64 编码。接收方用于执行 DH 棘轮步骤。\tmessage_number_in_chain\tint\t否\t此消息在当前发送链中的序号 (N)，从 0 开始计数。\tprevious_message_number_in_chain\tint\t否\t发送方在上一个发送链（即上一次 DH 棘轮步骤之后）中已发送的消息总数 (PN)。用于处理乱序。\t\nTODO：下面的内容后续移动到更加合适的文件里面","signal-协议流程说明-e2ee-模式#Signal 协议流程说明 (E2EE 模式)":"","初始会话建立-prekey-消息#初始会话建立 (PreKey 消息)":"Alice 想要给 Bob 发送第一条 E2EE 消息:\nAlice 通过某种机制 (例如 QUERY_USER_PREKEYS_REQUEST - 此请求需要单独定义) 获取 Bob 的公钥包 (包括身份公钥 IK_B, 签名预共享密钥 SPK_B, SPK_B 的签名 Sig(IK_B, Encode(SPK_B)), 和一组一次性预共享密钥 OPK_B)。\nAlice 验证 Bob 的 SPK_B 的签名。\nAlice 生成自己的临时密钥对 EK_A。\nAlice 使用 Signal 协议的 X3DH 密钥协商过程，结合自己的身份密钥 IK_A、临时密钥 EK_A，以及 Bob 的 IK_B、SPK_B (和可选的 OPK_B)，计算出初始的共享对称密钥 SK。\nAlice 使用 SK 加密消息，创建 MessageContent 对象，其中：\ntype 设置为 \"prekey\"。\nbody 为加密后的密文 (Base64 编码)。\n包含 sender_identity_public_key (Alice 的 IK_A_pub Base64)。\n包含 sender_ephemeral_public_key (Alice 的 EK_A_pub Base64)。\n包含 recipient_signed_pre_key_id (Bob 被使用的 SPK_B 的 ID)。\n如果使用了 Bob 的 OPK，则包含 recipient_one_time_pre_key_id (Bob 被使用的 OPK_B 的 ID)。\nAlice 发送 SEND_PRIVATE_CHAT_MESSAGE_REQUEST，其 payload.content 为上述构建的 MessageContent 对象。\nBob 接收 Alice 的 PreKey 消息:\nBob 通过 RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION 收到消息，其中 payload.content 包含 Alice 发来的 MessageContent (type=\"prekey\")。\nBob 使用自己的私钥 (IK_B_priv, SPK_B_priv, 以及被使用的 OPK_B_priv) 和 Alice 消息中提供的公钥信息 (sender_identity_public_key, sender_ephemeral_public_key)，同样通过 X3DH 过程重新计算出相同的共享对称密钥 SK。\nBob 使用 SK 解密 content.body，并初始化双棘轮会话状态。","后续消息-ratchet-消息#后续消息 (Ratchet 消息)":"后续的对话:\nAlice 和 Bob 使用已初始化的双棘轮算法进行后续消息加密。\n发送方创建 MessageContent 对象，其中：\ntype 设置为 \"ratchet\"。\nbody 为使用当前消息密钥加密的密文 (Base64 编码)。\n包含 ratchet_header，其中含有当前发送棘轮公钥、链内消息序号和上一链的消息数。\nPreKey 特有的字段在 MessageContent (type=\"ratchet\") 中不再出现。","服务器处理规则-1#服务器处理规则":"透明转发 content: 服务器不修改 MessageContent 对象内的任何字段。它将 SEND_PRIVATE_CHAT_MESSAGE_REQUEST 中的 payload.content 对象原封不动地放入 RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION 的 payload.content 中转发给接收方。\n不关心内容类型: 服务器的转发逻辑不依赖于 MessageContent.type 的具体值。","安全特性e2ee-模式下#安全特性（E2EE 模式下）":"（此部分与原文一致，因为基础的 Signal 协议特性未变）\n前向安全性: 双棘轮算法确保即使私钥泄露，过去的消息仍然安全。\n后向安全性 / 未来保密性 (Post-Compromise Security): 如果会话状态在某个点被攻破，双棘轮算法能够通过 DH 交换自动恢复安全通信。\n乱序消息处理: 通过消息序号处理网络中的乱序消息。\n密钥验证: 身份公钥的参与和预共享密钥的签名有助于防止某些类型的攻击（但完整的身份验证可能还需要其他机制，如安全码比较）。"}},"/sequence":{"title":"Sequence Flow","data":{"":"This section provides a detailed view of the message flow within the Whisper system, illustrating how different components interact during typical operations.","message-delivery-sequence#Message Delivery Sequence":"The following diagram illustrates the sequence of events that occurs when a message is sent from one user to another:","authentication-flow#Authentication Flow":"The following diagram illustrates the authentication process when a user logs into Whisper:","group-chat-creation#Group Chat Creation":"This diagram shows the process of creating a new group chat:","message-synchronization-across-devices#Message Synchronization Across Devices":"This diagram illustrates how messages are synchronized across multiple devices belonging to the same user:","media-sharing-flow#Media Sharing Flow":"The following sequence diagram illustrates how media files are shared between users:"}},"/sequences/authentication":{"title":"Authentication","data":{}},"/sequences/group_chat":{"title":"Group Chat","data":{}},"/sequences/presence":{"title":"Presence","data":{}},"/stress-test":{"title":"Dynamic Stress Testing","data":{"":"Running stress tests will generate significant load on the Whisper servers. Please use the test environment for these operations.","performance-under-load#Performance Under Load":"Whisper is designed to handle high volumes of concurrent connections and message exchanges. This page allows you to visualize the performance of Whisper under various load conditions through real-time testing.","testing-methodology#Testing Methodology":"Our stress testing approach evaluates several key metrics:\nConcurrent Connection Capacity: How many simultaneous WebSocket connections the system can maintain\nMessage Throughput: The number of messages that can be processed per second\nLatency: The time it takes for a message to travel from sender to recipient\nResource Utilization: CPU, memory, and network usage under load\nError Rates: The percentage of failed operations under various load conditions","test-scenarios#Test Scenarios":"The stress test dashboard allows you to run the following test scenarios:","scenario-1-gradual-connection-ramp-up#Scenario 1: Gradual Connection Ramp-Up":"This test gradually increases the number of concurrent connections to identify the system's scaling characteristics and potential breaking points.","scenario-2-message-burst-test#Scenario 2: Message Burst Test":"This test sends a sudden burst of messages from multiple clients to measure how the system handles traffic spikes.","scenario-3-long-running-stability-test#Scenario 3: Long-Running Stability Test":"This test maintains a steady load over an extended period to identify potential resource leaks or performance degradation over time.","scenario-4-mixed-workload-test#Scenario 4: Mixed Workload Test":"This test simulates a realistic usage pattern with a mix of different operations (sending messages, reading messages, creating groups, etc.).","interpreting-results#Interpreting Results":"The dashboard provides real-time visualizations of:\nActive connections over time\nMessage throughput (messages/second)\nMessage latency distribution\nError rates by operation type\nServer resource utilization\nWhen analyzing the results, pay attention to:\nInflection Points: Where performance metrics start to degrade\nError Rate Spikes: Sudden increases in failed operations\nLatency Increases: Growing delays in message delivery\nResource Saturation: CPU, memory, or network bottlenecks","system-optimizations#System Optimizations":"Based on stress test results, Whisper implements several optimizations:\nConnection Pooling: Efficient management of database connections\nMessage Batching: Grouping multiple messages into single database operations\nCaching Layer: In-memory caching of frequently accessed data\nLoad Balancing: Distribution of traffic across multiple server instances\nDatabase Sharding: Horizontal partitioning of data based on user or conversation IDs\nLazy Loading: Prioritizing critical data and deferring non-essential content\nThe stress test dashboard connects to Whisper's test environment. Results may vary compared to production performance due to different infrastructure configurations."}},"/sequences/private_chat":{"title":"Private Chat","data":{}},"/uml":{"title":"UML Structure","data":{"":"This page presents the Unified Modeling Language (UML) diagrams that describe the architecture and class relationships of the Whisper Chat application.","core-component-structure#Core Component Structure":"The following class diagram illustrates the main components of the Whisper system and their relationships:","architecture-layers#Architecture Layers":"This diagram illustrates the layered architecture of the Whisper application:","message-encryption-flow#Message Encryption Flow":"The following diagram illustrates how message encryption works within Whisper:","notification-system#Notification System":"This diagram shows the components involved in Whisper's notification system:","websocket-connection-management#WebSocket Connection Management":"This diagram illustrates how Whisper manages WebSocket connections:","data-consistency-and-synchronization#Data Consistency and Synchronization":"This diagram illustrates Whisper's approach to data consistency and synchronization across devices:","server-architecture#Server Architecture":"This diagram shows the server-side architecture of Whisper:\nThese UML diagrams provide a comprehensive view of Whisper's architecture, helping developers understand how the various components work together to create a secure, efficient real-time communication system."}}}