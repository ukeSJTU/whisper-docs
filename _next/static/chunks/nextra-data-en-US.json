{"/database":{"title":"Database Design","data":{"":"This section outlines the database architecture that powers Whisper Chat,\nincluding table structures, relationships, and optimization strategies.","database-architecture#Database Architecture":"Whisper uses a PostgreSQL database with specialized extensions to handle the unique requirements of a real-time messaging platform. The database is designed to optimize for:\nHigh read/write throughput\nLow-latency queries\nData integrity and consistency\nEfficient search capabilities\nScalability for millions of users and messages","schema-diagram#Schema Diagram":"The following diagram illustrates the relationships between the main entities in Whisper's database:","core-tables#Core Tables":"","users-table#Users Table":"The users table stores essential information about Whisper users:\nCREATE TABLE users (\n  user_id UUID PRIMARY KEY,\n  username VARCHAR(64) NOT NULL UNIQUE,\n  email VARCHAR(255) NOT NULL UNIQUE,\n  display_name VARCHAR(128),\n  profile_picture_url TEXT,\n  status VARCHAR(64) DEFAULT 'offline',\n  last_seen TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\nCREATE INDEX idx_users_username ON users(username);\nCREATE INDEX idx_users_status ON users(status);","conversations-table#Conversations Table":"The conversations table represents chat conversations, which can be either direct (between two users) or groups:\nCREATE TABLE conversations (\n  conversation_id UUID PRIMARY KEY,\n  conversation_type VARCHAR(16) NOT NULL CHECK (conversation_type IN ('direct', 'group')),\n  title VARCHAR(128),\n  created_by UUID REFERENCES users(user_id),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\nCREATE INDEX idx_conversations_type ON conversations(conversation_type);\nCREATE INDEX idx_conversations_created_by ON conversations(created_by);","participants-table#Participants Table":"The participants table manages the relationship between users and conversations:\nCREATE TABLE participants (\n  participant_id UUID PRIMARY KEY,\n  user_id UUID NOT NULL REFERENCES users(user_id),\n  conversation_id UUID NOT NULL REFERENCES conversations(conversation_id),\n  role VARCHAR(16) DEFAULT 'member' CHECK (role IN ('admin', 'member')),\n  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  last_read_message_id UUID,\n  UNIQUE(user_id, conversation_id)\n);\nCREATE INDEX idx_participants_user ON participants(user_id);\nCREATE INDEX idx_participants_conversation ON participants(conversation_id);","messages-table#Messages Table":"The messages table stores all messages sent within the platform:\nCREATE TABLE messages (\n  message_id UUID PRIMARY KEY,\n  conversation_id UUID NOT NULL REFERENCES conversations(conversation_id),\n  sender_id UUID NOT NULL REFERENCES users(user_id),\n  message_type VARCHAR(16) NOT NULL CHECK (message_type IN ('text', 'media', 'system')),\n  content TEXT,\n  encrypted BOOLEAN DEFAULT TRUE,\n  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  edited_at TIMESTAMP WITH TIME ZONE,\n  parent_message_id UUID REFERENCES messages(message_id)\n);\nCREATE INDEX idx_messages_conversation ON messages(conversation_id);\nCREATE INDEX idx_messages_sender ON messages(sender_id);\nCREATE INDEX idx_messages_sent_at ON messages(sent_at);\nCREATE INDEX idx_messages_parent ON messages(parent_message_id);","media-table#Media Table":"The media table stores information about media files shared in messages:\nCREATE TABLE media (\n  media_id UUID PRIMARY KEY,\n  message_id UUID NOT NULL REFERENCES messages(message_id),\n  media_type VARCHAR(16) NOT NULL CHECK (media_type IN ('image', 'video', 'audio', 'document')),\n  file_name VARCHAR(255) NOT NULL,\n  file_size BIGINT NOT NULL,\n  mime_type VARCHAR(128) NOT NULL,\n  storage_path TEXT NOT NULL,\n  thumbnail_path TEXT,\n  metadata JSONB\n);\nCREATE INDEX idx_media_message ON media(message_id);\nCREATE INDEX idx_media_type ON media(media_type);","partitioning-strategy#Partitioning Strategy":"For high-scale deployments, Whisper implements table partitioning to improve query performance and maintenance operations:\nMessages are partitioned by date range (monthly), enabling efficient\narchiving and query optimization.\n-- Example of message table partitioning\nCREATE TABLE messages (\n  -- columns as defined above\n) PARTITION BY RANGE (sent_at);\n-- Create monthly partitions\nCREATE TABLE messages_y2023m01 PARTITION OF messages\n  FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\nCREATE TABLE messages_y2023m02 PARTITION OF messages\n  FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');\n-- Additional partitions as needed","indexing-strategy#Indexing Strategy":"Whisper employs a comprehensive indexing strategy to ensure optimal query performance:\nPrimary Key Indices: All tables have UUID primary keys\nForeign Key Indices: All foreign key columns are indexed\nCompound Indices: Created for frequently used query patterns\nPartial Indices: Used for filtering on common conditions\nGIN Indices: Used for JSONB and full-text search columns","data-access-patterns#Data Access Patterns":"The database design is optimized for these common data access patterns:\nAccess Pattern\tImplementation\tRetrieve recent messages\tIndex on (conversation_id, sent_at DESC)\tSearch message content\tFull-text search with GIN index\tUser conversation list\tJoin between users, participants, and conversations\tUnread message count\tComparison between last_read_message_id and latest message\tMedia gallery view\tIndex on (conversation_id, media_type)","backup-and-replication#Backup and Replication":"To ensure data durability and availability, Whisper employs:\nContinuous archiving with Point-in-Time Recovery (PITR)\nSynchronous replication to standby servers\nDaily full backups with 30-day retention\nCross-region backup storage","database-scaling#Database Scaling":"As user base grows, Whisper's database scales through:\nRead Replicas: For distributing read queries\nSharding: Horizontal partitioning by user geography or conversation ID\nConnection Pooling: Efficient management of database connections\nQuery Optimization: Regular query plan analysis and optimization\nCaching: Implementing Redis for frequently accessed data","redis#Redis":";"}},"/demo":{"title":"Whisper Chat Demo & Introduction","data":{"":"Whisper is currently in public beta. While the core functionality is stable,\nyou may encounter occasional issues as we continue to improve the platform.","what-is-whisper#What is Whisper?":"Whisper is a modern web-based chat application designed for secure, real-time communication. Built with privacy and performance as core principles, Whisper provides a seamless messaging experience across all devices.","core-features#Core Features":"","secure-communication#Secure Communication":"Whisper employs industry-standard encryption protocols to ensure that your messages remain private. All communications are encrypted end-to-end, meaning that only the intended recipients can read your messages.","real-time-messaging#Real-Time Messaging":"Experience seamless, real-time communication with instant message delivery, typing indicators, and read receipts. Whisper's architecture is optimized for low-latency communication, ensuring that your messages are delivered promptly.","multi-platform-support#Multi-Platform Support":"Whisper is available on all major platforms, including:\nWeb browsers (Chrome, Firefox, Safari, Edge)\niOS and Android mobile devices\nDesktop applications for Windows, macOS, and Linux","rich-media-sharing#Rich Media Sharing":"Share more than just text with Whisper's rich media support:\nImage and video sharing\nDocument attachments\nVoice messages\nLocation sharing\nCode snippets with syntax highlighting","group-conversations#Group Conversations":"Create group chats for team collaboration, family discussions, or social gatherings. Whisper supports:\nPublic and private groups\nRole-based permissions\nThread replies for organized discussions\nPinned messages for important information","technology-stack#Technology Stack":"Whisper is built on a modern technology stack designed for performance and scalability:\nFrontend: React, WebSocket API, WebRTC\nBackend: Node.js, Express, Socket.IO\nDatabase: PostgreSQL with real-time capabilities\nInfrastructure: Containerized microservices deployed on Kubernetes\nIn the following sections, we'll dive deeper into Whisper's architecture, exploring its protocol, sequence flows, database design, and performance characteristics.;"}},"/encrypt":{"title":"一对一聊天 (Private Chat with Signal Protocol)","data":{"概述#概述":"本部分详细阐述了基于 Signal 协议的端到端加密（E2EE）私聊机制。它首先通过 X3DH (Extended Triple Diffie-Hellman) 密钥协商协议在通信双方（例如 Alice 和 Bob）之间安全地建立一个初始共享密钥 SK。随后，此 SK 将用于初始化双棘轮 (Double Ratchet) 算法，为后续的持续通信提供前向保密和后向保密（或称破坏后恢复安全）。核心密钥类型回顾：\n身份密钥 (IK): 每个用户拥有一对长期的 Ed25519 密钥对。IK_pub 用于身份声明和验证签名预共享密钥 (SPK)；IK_priv 用于签名 SPK。在 X3DH 中，当 IK 需要参与 DH 运算时，其公钥会被转换为 X25519 形式，其私钥会以对应的 X25519 私钥标量形式参与。\n签名预共享密钥 (SPK): 一对中期的 X25519 密钥对，其公钥被 IK 签名。\n一次性预共享密钥 (OPK): 一批一次性的 X25519 密钥对。\n临时密钥 (EK): 由会话发起方（Alice）为单次 X3DH 交换生成的 X25519 密钥对。","流程详解#流程详解":"","阶段-0-bob-的设置与公钥包上传-一次性或不经常进行#阶段 0: Bob 的设置与公钥包上传 (一次性或不经常进行)":"在 Alice 能够联系 Bob 之前，Bob 的客户端（例如通过 SignalKeyStore 和 SignalProtocolManager）需要完成以下操作：\n生成各类密钥对：\n身份密钥对 (IK_B)：一对长期的 Ed25519PrivateKey 和 Ed25519PublicKey。\n(为了 X3DH) Bob 的客户端还需要能够从 IK_B_Ed25519_priv 的种子派生出对应的 X25519 私钥标量 (IK_B_X25519_priv_scalar)。\n签名预共享密钥对 (SPK_B)：一对中期的 X25519PrivateKey 和 X25519PublicKey，并为其分配一个整数 ID (SPK_B_id)。\n对 SPK_B 的签名：使用 IK_B_Ed25519_priv 对 SPK_B_X25519_pub 的字节进行签名，得到 Signature_SPK_B。\n一次性预共享密钥对 (OPK_B)：生成一批（例如 100 个）一次性的 X25519PrivateKey 和 X25519PublicKey 对，并为每个公钥分配一个唯一的整数 ID (OPK_B_i_id)。\n上传公钥包至服务器：Bob 的客户端将以下公钥信息打包发送给服务器存储。服务器绝不存储任何私钥。\nIK_B_Ed25519_pub (Bob 的 Ed25519 公共身份密钥)\nSPK_B_X25519_pub (Bob 的 X25519 公共签名预共享密钥)\nSPK_B_id\nSignature_SPK_B (对 SPK_B_pub 的签名)\n一个列表，包含所有公共一次性预共享密钥 (OPK_B_i_X25519_pub) 及其对应的 OPK_B_i_id。","阶段-1-alice-获取-bob-的公钥包#阶段 1: Alice 获取 Bob 的公钥包":"当 Alice 想要和 Bob 开始加密聊天时：\nAlice 的客户端向服务器请求 Bob 的公共预共享密钥包。\n服务器查找 Bob 的记录，并执行以下操作：\n提取 Bob 的 IK_B_Ed25519_pub, SPK_B_X25519_pub, SPK_B_id, 和 Signature_SPK_B。\n从 Bob 的可用 OPK 列表中选择一个 OPK_B_X25519_pub 及其 OPK_B_id（如果还有可用的话）。\n将这个被选中的 OPK 从 Bob 的可用列表中移除或标记为已使用。\n将上述所有公钥信息返回给 Alice 的客户端。","阶段-2-alice-计算共享密钥sk#阶段 2: Alice 计算共享密钥(SK)":"Alice 的客户端（例如其内部的 X3DHProtocol 模块）现在拥有：\n她自己的密钥：IK_A_Ed25519_priv (及其对应的 IK_A_X25519_priv_scalar)。\nBob 的公钥包中的信息。\nAlice 执行以下步骤：\n验证 Bob 的 SPK 签名：Alice 使用获取到的 IK_B_Ed25519_pub 来验证 Signature_SPK_B 对于 SPK_B_X25519_pub 的有效性。如果签名无效，则流程中止，因为 Bob 的密钥包可能已被篡改或来源不可信。\n生成 Alice 的临时密钥 (EK_A)：Alice 生成一对全新的 X25519 临时密钥对 (EK_A_X25519_priv, EK_A_X25519_pub)，仅用于本次会话建立。\n进行公钥转换：Alice 使用你实现的转换函数，将从 Bob 密钥包中获取的 IK_B_Ed25519_pub 转换为其对应的 X25519 公钥形式 (IK_B_X25519_pub_form)。\n执行 X3DH 运算：\nDH1 = X25519(IK_A_X25519_priv_scalar, SPK_B_X25519_pub)\nDH2 = X25519(EK_A_X25519_priv, IK_B_X25519_pub_form)\nDH3 = X25519(EK_A_X25519_priv, SPK_B_X25519_pub)\nDH4 = X25519(EK_A_X25519_priv, OPK_B_X25519_pub) (如果 Bob 提供了 OPK 并且 Alice 使用了它)\n构造输入密钥材料 (IKM)：Alice 将一个标准定义的固定前缀字节串 F（例如 32 个 \\xff 字节）与上述 DH 运算结果按照 Signal 协议规定的固定顺序拼接起来：\nIKM = F || DH1 || DH2 || DH3 || DH4 (如果 DH4 不存在则不包含)。\n派生共享密钥 (SK)：Alice 使用 HKDF（基于 HMAC 的密钥派生函数）从 IKM 派生出最终的 32 字节共享密钥 SK。HKDF 的 salt 和 info 参数也应使用 Signal 协议规范中的标准值。\nSK = HKDF(salt_spec, IKM, info_spec, 32)\n派生初始消息密钥 (MK_initial)：通常，SK 不会直接用于加密第一条消息，而是会再次通过 KDF（例如 HKDF 的扩展阶段，使用不同的 info）派生出一个或多个用于实际加密的初始消息密钥和相关的认证数据密钥。为简化，我们称之为 MK_initial。\n加密第一条消息：Alice 使用 MK_initial 和 AEAD 对称加密算法（如 AES-GCM，为每条消息使用唯一的 Nonce）加密她的第一条消息，得到密文。","阶段-3-alice-发送初始消息给服务器#阶段 3: Alice 发送初始消息给服务器":"Alice 的客户端构建一个初始的“预共享密钥消息”（PreKey Message）。根据我们之前讨论的协议，这会是一个 MessageContent 对象，其 type 字段为 \"prekey\"。该对象的 body 包含加密后的第一条消息密文，并且对象内部还需要包含以下由 Alice 提供的、Bob 建立会话所需的公钥信息和 ID：\nsender_identity_public_key: Alice 的 IK_A_Ed25519_pub (Base64 编码)。Bob 需要用它来（在未来，如果 Alice 也发布 SPK）验证 Alice 的密钥。\nsender_ephemeral_public_key: Alice 的 EK_A_X25519_pub (Base64 编码)。Bob 的核心 DH 运算需要它。\nrecipient_signed_pre_key_id: Alice 所使用的 Bob 的 SPK_B_id。\nrecipient_one_time_pre_key_id: Alice 所使用的 Bob 的 OPK_B_id（如果使用了）。\nAlice 将此 MessageContent 对象包装在 SEND_PRIVATE_MESSAGE_REQUEST 中发送给服务器，服务器简单地将此请求的 payload.content 部分转发给 Bob。","阶段-4--5-bob-接收初始消息计算-sk并解密#阶段 4 & 5: Bob 接收初始消息，计算 SK，并解密":"Bob 的客户端收到服务器转发来的包含上述 type=\"prekey\" 的 MessageContent 对象。\n提取信息：Bob 从消息中提取出 Alice 的 IK_A_Ed25519_pub、EK_A_X25519_pub，以及他自己被 Alice 使用的 SPK_B_id_used 和 OPK_B_id_used。\n获取自己的私钥：Bob 的客户端从其本地 SignalKeyStore 中获取：\n他自己的 IK_B_Ed25519_priv（并从中派生出 IK_B_X25519_priv_scalar）。\n与 SPK_B_id_used 对应的 SPK_B_X25519_priv。\n如果 OPK_B_id_used 存在，获取对应的 OPK_B_X25519_priv。获取后，Bob 的客户端应将此 OPK 从可用池中永久删除。\n进行公钥转换：Bob 使用你实现的转换函数，将消息中 Alice 的 IK_A_Ed25519_pub 转换为其对应的 X25519 公钥形式 (IK_A_X25519_pub_form)。\n执行 X3DH 运算：Bob 使用自己的私钥和 Alice 的公钥（包括转换后的IK_A_X25519_pub_form和EK_A_X25519_pub）进行与 Alice 完全相同的四组（或三组）DH 运算。\n构造 IKM 并派生 SK：Bob 按照与 Alice完全相同的固定顺序和前缀 F拼接 DH 结果，得到 IKM，然后使用完全相同的 HKDF 参数派生出共享密钥 SK。\n此时，Bob 计算出的 SK 将与 Alice 计算出的 SK 完全一致！\n派生并使用初始消息密钥解密：Bob 同样从 SK 派生出 MK_initial，然后用它解密 MessageContent.body 中的密文，得到 Alice 发送的第一条明文消息。","阶段-6-双棘轮初始化和后续通信#阶段 6: 双棘轮初始化和后续通信":"一旦双方都拥有了相同的共享密钥 SK，他们就可以用它来初始化双棘轮会话状态。\nSK 作为第一个根密钥 (RootKey, RK0)。\nAlice 的初始状态：\n她的第一个发送棘轮公钥（DHRs_A）就是她在 X3DH 中生成的 EK_A_X25519_pub。\n她需要 Bob 的初始棘轮公钥来初始化她的接收链。Bob 的这个公钥将在 Bob 的第一条回复消息中携带。在收到 Bob 的回复前，Alice 的接收链是基于 DH(IK_A_X_form, Bob的被选PreKey_pub) 或 DH(EK_A_priv, Bob的被选PreKey_pub) 等（具体取决于 Signal 棘轮的精确初始化步骤，通常是基于 Bob 的 SPK 或 OPK）。\nBob 的初始状态：\n他收到了 Alice 的 EK_A_X25519_pub，这成为他的第一个接收棘轮公钥 (DHRrcv_A)。\n为了回复 Alice，Bob 会生成他自己的第一个发送棘轮密钥对 (DHRs_B_pair)。其公钥 DHRs_B_pub 将包含在他发送给 Alice 的第一条棘轮消息中。\n然后，Bob 使用 RK0 (即SK) 和 DH(DHRs_B_priv, DHRrcv_A) 的结果，通过 KDF 派生出他自己的初始发送链密钥 (CKs_B) 和接收链密钥 (CKr_B)。\n“棘轮状态同步”的关键在于：\n双方通过 X3DH 安全地协商出相同的 SK。\nSK 作为双棘轮的第一个根密钥。\n双方都知道对方用于开始双棘轮的第一个棘轮公钥（Alice 的是她的EK_A_pub，Bob 则在他回复第一条消息时生成并发送他自己的第一个棘轮公钥 DHRs_B_pub）。\n基于这些信息，双方各自初始化发送链和接收链，双棘轮开始运作。之后，每条消息的发送和接收都会驱动棘轮前进，不断生成新的消息密钥。\n这个过程确保了即使初始的 SK 或某个阶段的密钥泄露，由于棘轮机制（特别是 DH 棘轮），未来的消息仍能保持其机密性（前向保密），并且过去的通信在一定程度上也能得到保护。实现这些需要对 Signal 协议规范的精确理解和严谨编程。"}},"/":{"title":"Whisper Chat Documentation","data":{"":"Whisper 是一款支持端到端加密的即时通讯应用，支持跨平台使用。","key-features#Key Features":"Whisper 是一款支持端到端加密的即时通讯应用，支持跨平台使用。\n用户注册/登录/登出\n私聊消息\n群聊消息\n用户在线状态展示\n高并发\n心跳机制\n消息撤回","getting-started#Getting Started":"Try the Whisper Demo to get a feel for how Whisper works."}},"/protocol":{"title":"Whisper Protocol Specification","data":{"1-通用消息格式与约定-general-message-format--conventions#1. 通用消息格式与约定 (General Message Format & Conventions)":"所有客户端 (Client) 与服务器 (Server) 之间的通信都遵循统一的帧结构和 JSON 负载结构。","11-网络帧结构-network-frame-structure#1.1. 网络帧结构 (Network Frame Structure)":"每条消息在 TCP 流中都带有头部，指明消息总长度：\n字段\t字节数\t类型\t描述\t消息总长度\t4\tUnsigned Int\t包括头部在内的整条消息的字节长度 (网络字节序 Big Endian)\tJSON 负载\t剩余字节\tString (UTF-8)\t实际的 JSON 格式的业务数据","12-json-负载通用结构-general-json-payload-structure#1.2. JSON 负载通用结构 (General JSON Payload Structure)":"网络帧结构中的\"JSON 负载\"部分采用以下通用结构：\n{\n    \"message_id\": \"unique_uuid_string_for_this_message_envelope\",\n    \"type\": \"MESSAGE_TYPE_STRING_IDENTIFIER\",\n    \"timestamp\": \"iso_8601_datetime_string_utc\",\n    \"token\": \"session_token_string_or_null\",\n    \"correlation_id\": \"echoed_request_message_id_or_null\",\n    \"payload\": {\n        // --- 特定消息类型的具体负载内容 ---\n    }\n}\n通用 JSON 字段说明:\n参数名\t类型\tOptional?\t描述\t示例\tmessage_id\tstring (UUID)\t否\t此消息信封的唯一标识符。\t\"a1b2c3d4-e5f6-7890-1234-567890abcdef\"\ttype\tstring\t否\t消息类型的字符串标识符 (与头部中的消息类型 ID 对应，便于人类阅读和调试)。\t\"LOGIN_REQUEST\"\ttimestamp\tstring (ISO8601)\t否\t消息创建时的 UTC 时间戳。\t\"2025-05-15T15:30:00Z\"\ttoken\tstring\t是 (可为 null)\t用户会话令牌。对于需要认证的请求，此字段必须提供。对于未认证请求（如注册、登录），此字段为null。\t\"valid_session_token_here\" 或 null\tcorrelation_id\tstring (UUID)\t是 (可为 null)\t对于响应类型的消息，此字段应包含其对应的请求消息的message_id。对于请求或通知，此字段为null。\t\"a1b2c3d4-e5f6-7890-1234-567890abcdef\" 或 null\tpayload\tobject\t否\t包含此消息类型特定数据的对象。其结构在后续各消息类型中详细定义。\t{...}","按照功能划分的具体协议#按照功能划分的具体协议":"","概述#概述":"本部分定义了用户注册、登录、登出的相关协议。","21-用户注册-user-registration#2.1. 用户注册 (User Registration)":"","register_request-client---server#REGISTER_REQUEST (Client -> Server)":"消息类型 ID: 101\nJSON type 字符串: \"REGISTER_REQUEST\"\n{\n    \"message_id\": \"c4a2b1e0-dbb8-4a94-83d3-c7d0b6a8f9c0\",\n    \"type\": \"REGISTER_REQUEST\",\n    \"timestamp\": \"2025-05-15T10:00:00Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"username\": \"newuser\",\n        \"password\": \"a_strong_password\",\n        \"identity_public_key\": \"base64_encoded_X25519_public_key_optional\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tusername\tstring\t否\t用户希望注册的用户名，服务器需校验唯一性。\t\"newuser\"\tpassword\tstring\t否\t用户设置的密码。注意: 客户端应通过 TLS 等安全通道发送。服务器负责安全地哈希和存储密码。\t\"a_strong_password\"\tidentity_public_key\tstring\t是\t用户可选提供的身份公钥 (例如 X25519), Base64 编码的字符串表示。\t\"base64_encoded_X25519_public_key_optional\"","register_response-server---client#REGISTER_RESPONSE (Server -> Client)":"消息类型 ID: 102\nJSON type 字符串: \"REGISTER_RESPONSE\"\n{\n    \"message_id\": \"s8f7e6d5-c4b3-2a10-9876-fedcba098765\",\n    \"type\": \"REGISTER_RESPONSE\",\n    \"timestamp\": \"2025-05-15T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c4a2b1e0-dbb8-4a94-83d3-c7d0b6a8f9c0\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Registration successful!\",\n        \"user_id\": \"usr_sj20djn2\",\n        \"ephemeral_public_key\": \"\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t注册是否成功。\ttrue\tmessage\tstring\t否\t注册结果的描述信息 (例如 \"Registration successful!\", \"Username already exists.\")\t\"Registration successful!\"\tuser_id\tstring\t是\t如果注册成功，服务器分配的唯一用户 ID。\t\"usr_sj20djn2\"\tephemeral_public_key\tstring\t是\t用户可选提供的当前会话临时公钥 (X25519 ek_pub), Base64 编码的字符串表示。\t\"\"","22-用户登录-user-login#2.2. 用户登录 (User Login)":"","login_request-client---server#LOGIN_REQUEST (Client -> Server)":"消息类型 ID: 103\nJSON type 字符串: \"LOGIN_REQUEST\"\n{\n    \"message_id\": \"c5b8c1f0-eac9-4b95-84d4-d8e1c7a9g0d1\",\n    \"type\": \"LOGIN_REQUEST\",\n    \"timestamp\": \"2025-05-15T10:05:00Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"username\": \"existinguser\",\n        \"password\": \"user_password\",\n        \"ephemeral_public_key\": \"\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tusername\tstring\t否\t登录用户名。\t\"existinguser\"\tpassword\tstring\t否\t用户密码。 (同样注意 TLS 安全传输)\t\"user_password\"\tephemeral_public_key\tstring\t是\t用户可选提供的当前会话临时公钥 (X25519 ek_pub), Base64 编码的字符串表示。\t\"\"","login_response-server---client#LOGIN_RESPONSE (Server -> Client)":"消息类型 ID: 104\nJSON type 字符串: \"LOGIN_RESPONSE\"\n{\n    \"message_id\": \"s9g7f6e5-d4c3-3b11-9877-gfeda0987654\",\n    \"type\": \"LOGIN_RESPONSE\",\n    \"timestamp\": \"2025-05-15T10:05:01Z\",\n    \"token\": \"a_new_valid_session_token_if_success\",\n    \"correlation_id\": \"c5b8c1f0-eac9-4b95-84d4-d8e1c7a9g0d1\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Login successful!\",\n        \"user_id\": \"usr_existing123\",\n        \"username\": \"existinguser\",\n        \"low_opk_count_warning\": false\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t登录是否成功。\ttrue\tmessage\tstring\t否\t登录结果的描述信息。\t\"Login successful!\"\tuser_id\tstring\t是\t如果登录成功，用户的唯一 ID。\t\"usr_existing123\"\tusername\tstring\t是\t如果登录成功，用户的用户名 (方便客户端确认)。\t\"existinguser\"\tlow_opk_count_warning\tboolean\t是\t如果为true，表示服务器检测到该用户在服务器上存储的一次性预共享密钥(OTPKey)数量偏低，客户端应尽快上传新的一批 OTPKey。\tfalse\t\n注意: 成功登录后，响应的顶层 token 字段将包含会话令牌。客户端后续请求需携带此令牌。","23-用户登出-user-logout#2.3. 用户登出 (User Logout)":"","logout_request-client---server#LOGOUT_REQUEST (Client -> Server)":"消息类型 ID: 105\nJSON type 字符串: \"LOGOUT_REQUEST\"\n{\n    \"message_id\": \"c6d9e2g1-fbd0-4c96-85e5-e9f2d8b0h1e2\",\n    \"type\": \"LOGOUT_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:00:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {}\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\t(空)\tN/A\tN/A\t登出请求的 payload 为空。\t{}","logout_response-server---client#LOGOUT_RESPONSE (Server -> Client)":"消息类型 ID: 106\nJSON type 字符串: \"LOGOUT_RESPONSE\"\n{\n    \"message_id\": \"sa0h8g7f-e5d4-4c12-9878-hgfedb098765\",\n    \"type\": \"LOGOUT_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c6d9e2g1-fbd0-4c96-85e5-e9f2d8b0h1e2\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Logout successful.\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tsuccess\tboolean\t否\t登出是否成功。\ttrue\tmessage\tstring\t否\t登出结果的描述信息。\t\"Logout successful.\"","3-私聊聊天-private-chat#3. 私聊聊天 (Private Chat)":"","概述-1#概述":"本部分定义了支持双模式的一对一私聊消息系统：\n端到端加密 (E2EE)模式：基于 Signal 协议，使用预共享密钥(PreKey)机制建立初始会话，然后使用双棘轮(Double Ratchet)算法进行后续消息加密。\n明文模式：直接传输未经加密的文本消息，用于简化实现或特定非敏感场景。\n客户端在发送消息时，将通过 MessageContent 对象中的 type 字段指明所使用的模式。服务器主要负责透明转发消息内容。\n注意：本文档中所有时间戳字段在 API 中以 ISO8601 格式字符串表示（如\"2025-05-15T11:05:00Z\"），但在实际代码实现中使用 datetime 对象进行处理。","31-发送私聊消息-send-private-message#3.1. 发送私聊消息 (Send Private Message)":"","send_private_chat_message_request-client---server#SEND_PRIVATE_CHAT_MESSAGE_REQUEST (Client -> Server)":"消息类型 ID: 201\nJSON type 字符串: \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\"\nJSON 示例 (E2EE - PreKey 消息):\n{\n    \"message_id\": \"c7e0f3h2-gcd1-4d97-86f6-f0g3e9c1i2f3\",\n    \"type\": \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:05:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend456\",\n        \"content\": {\n            \"type\": \"prekey\",\n            \"body\": \"U29tZSBFbmNyeXB0ZWQgRGF0YQ==\",\n            \"sender_identity_public_key\": \"base64_sender_IK_pub\",\n            \"sender_ephemeral_public_key\": \"base64_sender_EK_pub\",\n            \"recipient_signed_pre_key_id\": 123456,\n            \"recipient_one_time_pre_key_id\": 123457\n        },\n        \"client_message_id\": \"client_msg_uuid_001\"\n    }\n}\nJSON 示例 (明文消息):\n{\n    \"message_id\": \"p9a8b7c6-d5e4-f3g2-h1i0-j9k8l7m6n5o4\",\n    \"type\": \"SEND_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:07:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend789\",\n        \"content\": {\n            \"type\": \"plaintext\",\n            \"body\": \"你好，这是一条明文消息！\"\n        },\n        \"client_message_id\": \"client_msg_uuid_002\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\trecipient_user_id\tstring\t否\t消息接收者的用户 ID。\t\"usr_friend456\"\tcontent\tMessageContent\t否\t消息内容对象。其具体结构和字段取决于 content.type 的值。详见下方 MessageContent 定义。\t{...}\tclient_message_id\tstring\t是\t客户端生成的消息 ID，用于追踪消息发送状态。服务端在 ACK 中会回显此 ID。\t\"client_msg_uuid_001\"","private_chat_message_sent_ack-server---client-to-sender#PRIVATE_CHAT_MESSAGE_SENT_ACK (Server -> Client, to Sender)":"消息类型 ID: 202 (通用于私聊和群聊消息发送确认)\nJSON type 字符串: \"PRIVATE_CHAT_MESSAGE_SENT_ACK\"\n此消息结构保持不变，因为它只确认服务器已处理消息，不关心内容是明文还是密文。JSON 示例:\n{\n    \"message_id\": \"sb1i9h8g-f6e5-5d13-9879-ihgfedb09876\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_SENT_ACK\",\n    \"timestamp\": \"2025-05-15T11:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"c7e0f3h2-gcd1-4d97-86f6-f0g3e9c1i2f3\",\n    \"payload\": {\n        \"status_message\": \"Message processed by server.\",\n        \"server_message_id\": \"srv_msg_xyz789\",\n        \"client_message_id\": \"client_msg_uuid_001\",\n        \"message_timestamp\": \"2025-05-15T11:05:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tstatus_message\tstring\t否\t消息处理状态 (例如 \"Message processed by server\", \"Recipient offline, message stored\").\t\"Message processed by server.\"\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID。\t\"srv_msg_xyz789\"\tclient_message_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显。\t\"client_msg_uuid_001\"\tmessage_timestamp\tstring (ISO8601)\t否\t消息在服务端被处理并分配 server_message_id 时的精确时间戳。客户端应使用此时间戳更新本地消息记录。\t\"2025-05-15T11:05:00Z\"","32-接收私聊消息-receive-private-message#3.2. 接收私聊消息 (Receive Private Message)":"","receive_private_chat_message_notification-server---client-to-recipient#RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION (Server -> Client, to Recipient)":"消息类型 ID: 203\nJSON type 字符串: \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\"\n服务器将 SEND_PRIVATE_CHAT_MESSAGE_REQUEST 中的 content 对象原样转发给接收方。JSON 示例 (E2EE - PreKey 消息):\n{\n    \"message_id\": \"sc2j0i9h-g7f6-6e14-9870-jihgfedb0987\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:05:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id\": \"srv_msg_xyz789\",\n        \"sender_user_id\": \"usr_sender123\",\n        \"sender_username\": \"SenderName\",\n        \"content\": {\n            \"type\": \"prekey\",\n            \"body\": \"U29tZSBFbmNyeXB0ZWQgRGF0YQ==\",\n            \"sender_identity_public_key\": \"base64_sender_IK_pub\",\n            \"sender_ephemeral_public_key\": \"base64_sender_EK_pub\",\n            \"recipient_signed_pre_key_id\": 123456,\n            \"recipient_one_time_pre_key_id\": 123457\n        },\n        \"message_timestamp\": \"2025-05-15T11:05:00Z\"\n    }\n}\nJSON 示例 (明文消息):\n{\n    \"message_id\": \"rd3k1j0i-h8g7-7f15-9871-kjihgfedcba0\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:07:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id\": \"srv_msg_abc123\",\n        \"sender_user_id\": \"usr_another_sender\",\n        \"sender_username\": \"AnotherSenderName\",\n        \"content\": {\n            \"type\": \"plaintext\",\n            \"body\": \"你好，这是一条来自服务器转发的明文消息！\"\n        },\n        \"message_timestamp\": \"2025-05-15T11:07:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID。\t\"srv_msg_xyz789\"\tsender_user_id\tstring\t否\t消息发送者的用户 ID。\t\"usr_sender123\"\tsender_username\tstring\t否\t消息发送者的用户名。\t\"SenderName\"\tcontent\tMessageContent\t否\t消息内容对象。接收方客户端根据其内部的 type 字段进行相应处理。详见 MessageContent 定义。\t{...}\tmessage_timestamp\tstring (ISO8601)\t否\t消息的原始发送时间戳（即发送方客户端创建消息时的时间戳）。\t\"2025-05-15T11:05:00Z\"\t\n好的，我们将在您现有的一对一聊天协议基础上添加撤回消息的功能。核心思路是：\n发送方 发起一个撤回请求，指明要撤回的服务器消息 ID (server_message_id)。\n服务器 验证请求（例如，是否是消息的原始发送者，是否在允许的时间窗口内——如果需要定义时间窗口的话），然后通知接收方该消息已被撤回。\n接收方客户端 收到撤回通知后，在其本地将对应消息标记为已撤回或直接移除。\n服务器也会给发送方一个撤回操作的确认。\n由于端到端加密 (E2EE) 的特性，服务器无法读取消息内容，也无法\"删除\"已发送到接收方设备并可能已被解密的消息内容。撤回操作本质上是发送一个\"指令\"，告知接收方客户端\"请将 ID 为 X 的消息视为已撤回\"。接收方客户端负责执行此操作。以下是协议的补充部分：","33-撤回私聊消息-recall-private-message#3.3. 撤回私聊消息 (Recall Private Message)":"本节定义了用户撤回已发送私聊消息的机制。撤回操作针对的是 server_message_id。","331-recall_private_chat_message_request-client---server-from-sender#3.3.1. RECALL_PRIVATE_CHAT_MESSAGE_REQUEST (Client -> Server, from Sender)":"消息类型 ID: 204\nJSON type 字符串: \"RECALL_PRIVATE_CHAT_MESSAGE_REQUEST\"\n当用户希望撤回一条已发送的消息时，客户端向服务器发送此请求。JSON 示例:\n{\n    \"message_id\": \"r3c4ll_req_uuid_001\",\n    \"type\": \"RECALL_PRIVATE_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:10:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"recipient_user_id\": \"usr_friend456\",\n        \"server_message_id_to_recall\": \"srv_msg_xyz789\",\n        \"client_recall_request_id\": \"client_recall_uuid_001\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\trecipient_user_id\tstring\t否\t原始消息接收者的用户 ID (即与谁的聊天会话中的消息)。\t\"usr_friend456\"\tserver_message_id_to_recall\tstring\t否\t需要被撤回的消息在服务器端生成的唯一 ID (server_message_id)。\t\"srv_msg_xyz789\"\tclient_recall_request_id\tstring\t是\t客户端生成的撤回请求 ID，用于追踪撤回请求的状态。服务端在 ACK 中会回显此 ID。\t\"client_recall_uuid_001\"","332-private_chat_message_recalled_ack-server---client-to-sender#3.3.2. PRIVATE_CHAT_MESSAGE_RECALLED_ACK (Server -> Client, to Sender)":"消息类型 ID: 205\nJSON type 字符串: \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\"\n服务器在处理完撤回请求后，向发起撤回的客户端发送此确认消息。JSON 示例 (成功):\n{\n    \"message_id\": \"ack_recall_srv_uuid_002\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-15T11:10:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"r3c4ll_req_uuid_001\",\n    \"payload\": {\n        \"status\": true,\n        \"status_message\": \"Message recall request processed successfully.\",\n        \"recalled_server_message_id\": \"srv_msg_xyz789\",\n        \"client_recall_request_id\": \"client_recall_uuid_001\"\n    }\n}\nJSON 示例 (失败 - 例如消息不存在或超时):\n{\n    \"message_id\": \"ack_recall_srv_uuid_003\",\n    \"type\": \"PRIVATE_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-15T11:10:02Z\",\n    \"token\": null,\n    \"correlation_id\": \"r3c4ll_req_uuid_002\",\n    \"payload\": {\n        \"status\": false,\n        \"status_message\": \"Message not found or recall window expired.\",\n        \"recalled_server_message_id\": \"srv_msg_nonexistent123\",\n        \"client_recall_request_id\": \"client_recall_uuid_002\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tstatus\tbool\t否\t撤回操作是否成功\ttrue\tstatus_message\tstring\t否\t描述撤回操作结果的消息。\t\"Message recall request processed successfully.\"\trecalled_server_message_id\tstring\t否\t被尝试撤回的消息的 server_message_id。\t\"srv_msg_xyz789\"\tclient_recall_request_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显。\t\"client_recall_uuid_001\"","333-receive_private_chat_message_recall_notification-server---client-to-recipient#3.3.3. RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION (Server -> Client, to Recipient)":"消息类型 ID: 206\nJSON type 字符串: \"RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION\"\n当一条消息被发送者撤回后，服务器向该消息的接收方发送此通知。JSON 示例:\n{\n    \"message_id\": \"ntf_recall_srv_uuid_004\",\n    \"type\": \"RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:10:03Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"server_message_id_to_recall\": \"srv_msg_xyz789\",\n        \"recalled_by_user_id\": \"usr_sender123\",\n        \"chat_partner_user_id\": \"usr_sender123\",\n        \"recall_timestamp\": \"2025-05-15T11:10:00Z\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\tserver_message_id_to_recall\tstring\t否\t被撤回的消息的 server_message_id。接收方客户端根据此 ID 找到并处理本地消息。\t\"srv_msg_xyz789\"\trecalled_by_user_id\tstring\t否\t发起撤回操作的用户 ID (即原始消息的发送者)。\t\"usr_sender123\"\tchat_partner_user_id\tstring\t否\t对于接收方而言，这是其聊天对象的 ID，即消息的发送者。\t\"usr_sender123\"\trecall_timestamp\tstring (ISO8601)\t否\t撤回操作发生的原始时间戳（即发送方客户端发起撤回请求的时间）。\t\"2025-05-15T11:10:00Z\"","撤回消息处理规则-message-recall-handling-rules#撤回消息处理规则 (Message Recall Handling Rules)":"","服务器处理规则#服务器处理规则:":"验证请求:\n验证 token 的有效性。\n验证发起撤回请求的用户是否是 server_message_id_to_recall 对应消息的原始发送者。\n(可选) 检查消息是否在允许的撤回时间窗口内（例如，发送后的 X 分钟内）。如果超出时间窗口，可以拒绝撤回。\n检查消息是否存在且尚未被撤回。\n处理撤回:\n如果验证通过，服务器应记录该消息已被撤回（例如，在数据库中标记）。这可以防止将来再次尝试传递该消息（如果它之前因接收方离线而未送达）。\n向发起撤回的客户端发送 PRIVATE_CHAT_MESSAGE_RECALLED_ACK。\n向消息的接收方客户端（recipient_user_id）发送 RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION。如果接收方当前不在线，则在其下次上线时发送此通知，类似于离线消息推送。\nE2EE 消息: 对于 E2EE 消息，服务器无法访问或修改消息内容。撤回操作仅针对消息的元数据和传递状态。服务器的角色是通知相关客户端发生了撤回事件。\n明文消息: 对于明文消息，服务器理论上可以从其存储中删除消息体（如果它有存储的话），但主要目的仍然是通知客户端。","客户端处理规则-发送方#客户端处理规则 (发送方):":"发起撤回: 用户选择撤回某条已发送的消息。客户端应使用该消息的 server_message_id (在 PRIVATE_CHAT_MESSAGE_SENT_ACK 中获得) 来构建 RECALL_PRIVATE_CHAT_MESSAGE_REQUEST。\n处理确认:\n收到 PRIVATE_CHAT_MESSAGE_RECALLED_ACK 后，根据 status 更新本地 UI。\n如果成功，可以在本地将对应消息标记为\"已撤回\"或更新其显示状态。\n如果失败 (例如超时、消息已被对方读取且服务器策略不允许再撤回等)，则向用户显示相应的错误信息。","客户端处理规则-接收方#客户端处理规则 (接收方):":"接收撤回通知: 收到 RECEIVE_PRIVATE_CHAT_MESSAGE_RECALL_NOTIFICATION。\n处理消息:\n根据 payload.server_message_id_to_recall 找到本地存储的对应消息。\n将该消息标记为\"已撤回\"。UI 上通常会显示类似\"此消息已被撤回\"的提示，而不是直接删除，以免造成对话上下文的困惑。\n重要: 如果消息是 E2EE 并且已被解密并存储在本地，客户端应确保该解密后的内容不再对用户可见。具体实现可以是删除解密内容，或用占位符替换。\n如果收到针对一条不存在的 server_message_id 的撤回通知（例如，由于网络延迟或状态不同步，消息在撤回通知到达前已被本地删除），客户端应静默忽略或记录一个低优先级的日志。","对-e2ee-模式的影响#对 E2EE 模式的影响:":"撤回功能不破坏 E2EE 的安全性。服务器仍然不知道消息内容。\n撤回的\"效力\"依赖于接收方客户端的正确实现。如果接收方客户端被篡改或不遵守协议，它可能不会隐藏已接收和解密的消息。\n一旦消息在接收端被解密并显示，撤回操作无法保证消息内容完全从接收者的视野或记忆中消失，它主要是在应用层面移除消息的展示。","数据结构定义#数据结构定义":"","messagecontent#MessageContent":"用于承载消息内容，支持明文、Signal PreKey 和 Signal Ratchet 三种类型。\n参数名\t类型\ttype 条件\t描述\t示例\ttype\tstring (enum)\t(所有类型共有)\t消息内容类型。必须是以下之一：\"plaintext\", \"prekey\", \"ratchet\"。\t\"prekey\"\tbody\tstring\t(所有类型共有)\t消息主体。如果 type 为 \"plaintext\"，则为 UTF-8 明文字符串；如果为 \"prekey\" 或 \"ratchet\"，则为 Base64 编码的密文字符串。\t\"Hello!\" 或 \"U29tZSBFbmN...\"\tsender_identity_public_key\tstring\t\"prekey\"\t仅当type为\"prekey\"时出现。 发送者的身份公钥 (IK_pub), Base64 编码。\t\"base64_sender_IK_pub\"\tsender_ephemeral_public_key\tstring\t\"prekey\"\t仅当type为\"prekey\"时出现。 发送者此次消息/会话的临时公钥 (EK_pub), Base64 编码。\t\"base64_sender_EK_pub\"\trecipient_signed_pre_key_id\tint\t\"prekey\"\t仅当type为\"prekey\"时出现。 接收方被使用的签名预共享密钥(SPK)的 ID。\t123456\trecipient_one_time_pre_key_id\tint\t\"prekey\" (可选)\t仅当type为\"prekey\"时出现。 接收方被使用的一次性预共享密钥(OPK)的 ID (如果 OPK 被使用)。\t123457\tratchet_header\tRatchetHeader\t\"ratchet\"\t仅当type为\"ratchet\"时出现。 包含双棘轮算法所需头部信息。如果type不为\"ratchet\"，此字段应为null或不存在。\t{...} (参见 RatchetHeader 定义)","ratchetheader#RatchetHeader":"用于双棘轮消息的头部信息（此结构保持不变）。\n参数名\t类型\tOptional?\t描述\tsender_ratchet_public_key\tstring\t否\t发送方当前棘轮公钥 (例如 X25519 的公钥)，Base64 编码。接收方用于执行 DH 棘轮步骤。\tmessage_number_in_chain\tint\t否\t此消息在当前发送链中的序号 (N)，从 0 开始计数。\tprevious_message_number_in_chain\tint\t否\t发送方在上一个发送链（即上一次 DH 棘轮步骤之后）中已发送的消息总数 (PN)。用于处理乱序。","4-在线状态与心跳-presence--heartbeat#4. 在线状态与心跳 (Presence & Heartbeat)":"","概述-2#概述":"本部分定义了用户在线状态管理和心跳检测机制。这些功能对于维护实时通信状态和确保连接活跃性至关重要。用户状态枚举值：协议支持以下用户状态值（对应代码中的 UserStatus 枚举）：\n\"ONLINE\" - 用户在线且活跃\n\"OFFLINE\" - 用户离线\n\"UNKNOWN\" - 用户状态未知 (例如，尝试查询的用户不存在于数据库中时，作为一种可能的标记，但更推荐使用标准的 ERROR_RESPONSE 来指示用户未找到)\n\"AWAY\" - 用户暂时离开\n\"BUSY\" - 用户忙碌中\n\"INVISIBLE\" - 用户隐身模式\n\"PENDING\" - 用户状态待定\n\"BANNED\" - 用户被禁止","51-心跳-heartbeat#5.1. 心跳 (Heartbeat)":"","heartbeat_request-client---server#HEARTBEAT_REQUEST (Client -> Server)":"消息类型 ID: 401\nJSON type 字符串: \"HEARTBEAT_REQUEST\"\nJSON 示例:\n{\n    \"message_id\": \"cb2i4k7m-lgk5-6h01-80j0-j4k7i3g5m6j7\",\n    \"type\": \"HEARTBEAT_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:20:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"client_timestamp\": \"2025-05-15T11:19:59Z\"\n    }\n}\nPayload (对应 HeartbeatRequestPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tclient_timestamp\tstring (ISO8601)\t否\t客户端发送心跳时的本地时间。Pydantic 模型中为 datetime 类型。\t\"2025-05-15T11:19:59Z\"","heartbeat_response-server---client#HEARTBEAT_RESPONSE (Server -> Client)":"消息类型 ID: 402\nJSON type 字符串: \"HEARTBEAT_RESPONSE\"\nJSON 示例:\n{\n    \"message_id\": \"sh7o5n4m-m2k1-1j19-9875-onmlkjihgfed\",\n    \"type\": \"HEARTBEAT_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:20:00Z\",\n    \"token\": null,\n    \"correlation_id\": \"cb2i4k7m-lgk5-6h01-80j0-j4k7i3g5m6j7\",\n    \"payload\": {\n        \"server_timestamp\": \"2025-05-15T11:20:00Z\"\n    }\n}\nPayload (对应 HeartbeatResponsePayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tserver_timestamp\tstring (ISO8601)\t否\t服务器当前时间。Pydantic 模型中为 datetime 类型。\t\"2025-05-15T11:20:00Z\"\t\n注意: HEARTBEAT_RESPONSE 是可选实现。如果客户端需要确认心跳被服务器接收，服务器应发送此响应。","52-用户状态更新-user-status-update#5.2. 用户状态更新 (User Status Update)":"","user_status_update_notification-server---client-to-relevant-clients#USER_STATUS_UPDATE_NOTIFICATION (Server -> Client, to relevant Clients)":"消息类型 ID: 403\nJSON type 字符串: \"USER_STATUS_UPDATE_NOTIFICATION\"\nJSON 示例:\n{\n    \"message_id\": \"si8p6o5n-n3l2-2k20-9876-ponmlkjihgfe\",\n    \"type\": \"USER_STATUS_UPDATE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-15T11:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"content\": {\n            \"user_id\": \"usr_friend456\",\n            \"username\": \"FriendUser\",\n            \"status\": \"ONLINE\",\n            \"last_seen\": null\n        }\n    }\n}\nPayload (对应 UserStatusUpdateNotificationPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tcontent\tUserStatusInfo\t否\t包含完整用户状态信息的对象。详见下方 UserStatusInfo 结构定义。","53-查询用户状态-query-user-status#5.3. 查询用户状态 (Query User Status)":"","query_user_status_request-client---server#QUERY_USER_STATUS_REQUEST (Client -> Server)":"消息类型 ID: 404\nJSON type 字符串: \"QUERY_USER_STATUS_REQUEST\"\nJSON 示例:\n{\n    \"message_id\": \"sj9q7p6o-o4n3-3l21-9877-qponmlkjihgf\",\n    \"type\": \"QUERY_USER_STATUS_REQUEST\",\n    \"timestamp\": \"2025-05-15T11:06:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"target_user_ids\": [\"usr_friend456\", \"usr_friend789\"]\n    }\n}\nPayload (对应 QueryUserStatusRequestPayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\ttarget_user_ids\tList[string]\t是 (Pydantic 模型中 default=[], 实际发送时可为空列表)\t要查询状态的用户 ID 列表。如果为空列表或 null (根据服务器实现处理 None 的方式)，服务器返回所有当前在线用户的状态信息。\t[\"usr_friend456\", \"usr_friend789\"]\t\n特殊行为：在线用户发现当 target_user_ids 为空列表 (或 null, 取决于服务器如何处理该字段的缺失或 None 值) 时，服务器返回所有当前在线用户的状态信息。这解决了新用户登录时的\"鸡生蛋、蛋生鸡\"问题：\n新用户登录后不知道有哪些用户在线。\n发送空的 target_user_ids 列表可以发现所有在线用户。\n之后可以通过状态更新通知保持同步。","query_user_status_response-server---client#QUERY_USER_STATUS_RESPONSE (Server -> Client)":"消息类型 ID: 405\nJSON type 字符串: \"QUERY_USER_STATUS_RESPONSE\"\nJSON 示例:\n{\n    \"message_id\": \"sk0s8r7q-p5o4-4n22-9878-srqponmlkjih\",\n    \"type\": \"QUERY_USER_STATUS_RESPONSE\",\n    \"timestamp\": \"2025-05-15T11:06:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"sj9q7p6o-o4n3-3l21-9877-qponmlkjihgf\",\n    \"payload\": {\n        \"results\": [\n            {\n                \"user_id\": \"usr_friend456\",\n                \"username\": \"FriendUser\",\n                \"status\": \"ONLINE\",\n                \"last_seen\": null\n            },\n            {\n                \"user_id\": \"usr_friend789\",\n                \"username\": \"AnotherFriend\",\n                \"status\": \"OFFLINE\",\n                \"last_seen\": \"2025-05-15T10:30:00Z\"\n            }\n        ]\n    }\n}\nPayload (对应 QueryUserStatusResponsePayload Pydantic 模型):\n参数名\t类型\tOptional?\t描述\t示例\tresults\tList[UserStatusInfo]\t否\t查询结果列表，包含每个用户的完整 UserStatusInfo 对象。","数据结构定义-1#数据结构定义":"","userstatusinfo#UserStatusInfo":"用户状态信息的完整结构 (对应 UserStatusInfo Pydantic 模型)：\n参数名\t类型\tOptional?\t描述\t示例\tuser_id\tstring (Pydantic: UserId)\t否\t用户的唯一 ID。\t\"usr_friend456\"\tusername\tstring\t否\t用户名。\t\"FriendUser\"\tstatus\tstring (Pydantic: UserStatus enum)\t否\t用户当前状态，使用上述枚举值之一。\t\"ONLINE\"\tlast_seen\tstring (ISO8601) (Pydantic: Optional[datetime])\t是\t用户最后活跃时间。根据你的定义，在线时可为 null，离线时提供时间戳。\t\"2025-05-15T10:30:00Z\" or null","5-群组聊天-group-chat#5. 群组聊天 (Group Chat)":"","概述-3#概述":"TODO: 添加 MLS 加密方案的改进版\n注意：本文档中所有时间戳字段在 API 中以 ISO8601 格式字符串表示（如\"2025-05-30T09:00:00Z\"），但在实际代码实现中使用 datetime 对象进行处理。","51-群组管理-group-management#5.1. 群组管理 (Group Management)":"","511-创建群组-create-group#5.1.1. 创建群组 (Create Group)":"用户创建一个新的群组。\nCREATE_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"CREATE_GROUP_REQUEST\"\n消息类型数字 ID: 501\nJSON 示例:\n{\n    \"message_id\": \"create_grp_req_001\",\n    \"type\": \"CREATE_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T09:00:00Z\",\n    \"token\": \"current_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_name\": \"Tech Discussion Group\",\n        \"group_description\": \"Share programming knowledge\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tgroup_description\tstring\t是\t群组描述 (可选)\t\"分享编程知识\"\t\nCREATE_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"CREATE_GROUP_RESPONSE\"\n消息类型数字 ID: 502\nJSON 示例 (成功):\n{\n    \"message_id\": \"create_grp_resp_001\",\n    \"type\": \"CREATE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"create_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Group created successfully\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Tech Discussion Group\",\n        \"group_description\": \"Share programming knowledge\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"create_grp_resp_002\",\n    \"type\": \"CREATE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"create_grp_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Group name already exists\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息 (例如 \"群组创建成功\")\t\"群组创建成功\"\tgroup_id\tstring\t是\t如果成功，返回新创建群组的唯一 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t如果成功，返回群组名称\t\"技术交流小组\"\tgroup_description\tstring\t是\t如果成功且提供，返回群组描述\t\"分享编程知识\"","512-更新群组信息-update-group-information#5.1.2. 更新群组信息 (Update Group Information)":"群组管理员更新群组的名称或描述。\nUPDATE_GROUP_INFO_REQUEST (Client -> Server)\n消息类型 ID (type string): \"UPDATE_GROUP_INFO_REQUEST\"\n消息类型数字 ID: 503\nJSON 示例:\n{\n    \"message_id\": \"update_grp_req_001\",\n    \"type\": \"UPDATE_GROUP_INFO_REQUEST\",\n    \"timestamp\": \"2025-05-30T09:30:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要更新的群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t新的群组名称 (如果更改)\t\"技术分享精英群\"\tgroup_description\tstring\t是\t新的群组描述 (如果更改)\t\"深入探讨前沿技术\"\t\nUPDATE_GROUP_INFO_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"UPDATE_GROUP_INFO_RESPONSE\"\n消息类型数字 ID: 504\nJSON 示例 (成功):\n{\n    \"message_id\": \"update_grp_resp_001\",\n    \"type\": \"UPDATE_GROUP_INFO_RESPONSE\",\n    \"timestamp\": \"2025-05-30T09:30:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"update_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Group information updated successfully\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"群组信息更新成功\"\tgroup_id\tstring\t是\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t更新后的群组名称 (如果成功且更改)\t\"技术分享精英群\"\tgroup_description\tstring\t是\t更新后的群组描述 (如果成功且更改)\t\"深入探讨前沿技术\"\t\nGROUP_INFO_UPDATED_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"GROUP_INFO_UPDATED_NOTIFICATION\"\n消息类型数字 ID: 505\nJSON 示例:\n{\n    \"message_id\": \"grp_info_updated_ntf_001\",\n    \"type\": \"GROUP_INFO_UPDATED_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T09:30:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"updated_by_user_id\": \"usr_admin_001\",\n        \"updated_by_username\": \"Admin John\",\n        \"new_group_name\": \"Advanced Tech Group\",\n        \"new_group_description\": \"Explore cutting-edge technology\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t被更新的群组 ID\t\"grp_uuid_123\"\tupdated_by_user_id\tstring\t否\t执行更新操作的用户 ID\t\"usr_admin_001\"\tupdated_by_username\tstring\t否\t执行更新操作的用户名\t\"管理员张三\"\tnew_group_name\tstring\t是\t更新后的群组名称 (如果更改)\t\"技术分享精英群\"\tnew_group_description\tstring\t是\t更新后的群组描述 (如果更改)\t\"深入探讨前沿技术\"","513-加入群组-join-group#5.1.3. 加入群组 (Join Group)":"用户请求加入一个群组。为简化，本协议假设服务器直接处理加入请求（例如，公开群组或服务器自动批准）。\nJOIN_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"JOIN_GROUP_REQUEST\"\n消息类型数字 ID: 506\nJSON 示例:\n{\n    \"message_id\": \"join_grp_req_001\",\n    \"type\": \"JOIN_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:00:00Z\",\n    \"token\": \"newbie_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要加入的群组 ID\t\"grp_uuid_123\"\t\nJOIN_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"JOIN_GROUP_RESPONSE\"\n消息类型数字 ID: 507\nJSON 示例 (成功):\n{\n    \"message_id\": \"join_grp_resp_001\",\n    \"type\": \"JOIN_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"join_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Successfully joined group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"成功加入群组\"\tgroup_id\tstring\t是\t群组 ID (如果成功)\t\"grp_uuid_123\"\tgroup_name\tstring\t是\t群组名称 (如果成功)\t\"技术交流小组\"\t\nUSER_JOINED_GROUP_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"USER_JOINED_GROUP_NOTIFICATION\"\n消息类型数字 ID: 508\nJSON 示例:\n{\n    \"message_id\": \"user_joined_ntf_001\",\n    \"type\": \"USER_JOINED_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"joined_user_id\": \"usr_newbie_007\",\n        \"joined_username\": \"NewUser Mike\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t相关群组 ID\t\"grp_uuid_123\"\tjoined_user_id\tstring\t否\t加入用户的 ID\t\"usr_newbie_007\"\tjoined_username\tstring\t否\t加入用户的用户名\t\"新手小明\"","514-退出群组-leave-group#5.1.4. 退出群组 (Leave Group)":"用户主动退出一个群组。\nLEAVE_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"LEAVE_GROUP_REQUEST\"\n消息类型数字 ID: 509\nJSON 示例:\n{\n    \"message_id\": \"leave_grp_req_001\",\n    \"type\": \"LEAVE_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T11:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t要退出的群组 ID\t\"grp_uuid_123\"\t\nLEAVE_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"LEAVE_GROUP_RESPONSE\"\n消息类型数字 ID: 510\nJSON 示例 (成功):\n{\n    \"message_id\": \"leave_grp_resp_001\",\n    \"type\": \"LEAVE_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T11:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"leave_grp_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"Successfully left group\",\n        \"group_id\": \"grp_uuid_123\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"成功退出群组\"\tgroup_id\tstring\t是\t群组 ID (如果成功)\t\"grp_uuid_123\"\t\nUSER_LEFT_GROUP_NOTIFICATION (Server -> Group Members)\n消息类型 ID (type string): \"USER_LEFT_GROUP_NOTIFICATION\"\n消息类型数字 ID: 511\nJSON 示例:\n{\n    \"message_id\": \"user_left_ntf_001\",\n    \"type\": \"USER_LEFT_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T11:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"left_user_id\": \"usr_oldbie_001\",\n        \"left_username\": \"Former User Bob\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t相关群组 ID\t\"grp_uuid_123\"\tleft_user_id\tstring\t否\t退出用户的 ID\t\"usr_oldbie_001\"\tleft_username\tstring\t否\t退出用户的用户名\t\"老王\"","515-获取群组列表-get-group-list#5.1.5. 获取群组列表 (Get Group List)":"客户端请求获取群组列表。如果提供用户 ID，则返回该用户加入的群组；否则返回服务器上的所有群组信息。\nGET_GROUPS_REQUEST (Client -> Server)\n消息类型 ID (type string): \"GET_GROUPS_REQUEST\"\n消息类型数字 ID: 518\nJSON 示例 (获取当前用户的群组):\n{\n    \"message_id\": \"get_groups_req_001\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {}\n}\nJSON 示例 (获取指定用户的群组):\n{\n    \"message_id\": \"get_groups_req_002\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"admin_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"user_id\": \"usr_target_001\"\n    }\n}\nJSON 示例 (获取所有群组):\n{\n    \"message_id\": \"get_groups_req_003\",\n    \"type\": \"GET_GROUPS_REQUEST\",\n    \"timestamp\": \"2025-05-30T12:00:00Z\",\n    \"token\": \"admin_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"get_all\": true\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tuser_id\tstring\t是\t指定用户 ID，获取该用户加入的群组列表\t\"usr_target_001\"\tget_all\tboolean\t是\t设为 true 时获取服务器上的所有群组\ttrue\t\nGET_GROUPS_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"GET_GROUPS_RESPONSE\"\n消息类型数字 ID: 519\nJSON 示例 (成功，有群组):\n{\n    \"message_id\": \"get_groups_resp_001\",\n    \"type\": \"GET_GROUPS_RESPONSE\",\n    \"timestamp\": \"2025-05-30T12:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"get_groups_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"groups\": [\n            {\n                \"group_id\": \"grp_uuid_123\",\n                \"group_name\": \"Advanced Tech Group\",\n                \"group_description\": \"Explore cutting-edge technology\",\n                \"last_message_snippet\": \"Hello everyone!\",\n                \"unread_count\": 2,\n                \"user_role\": null\n            },\n            {\n                \"group_id\": \"grp_uuid_456\",\n                \"group_name\": \"Product Discussion\",\n                \"group_description\": \"Discuss our products\",\n                \"last_message_snippet\": \"New feature discussion\",\n                \"unread_count\": 0,\n                \"user_role\": null\n            }\n        ]\n    }\n}\nJSON 示例 (成功，无群组):\n{\n    \"message_id\": \"get_groups_resp_002\",\n    \"type\": \"GET_GROUPS_RESPONSE\",\n    \"timestamp\": \"2025-05-30T12:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"get_groups_req_002\",\n    \"payload\": {\n        \"success\": true,\n        \"groups\": []\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tgroups\tArray[Object]\t是\t群组列表。如果为空则为空数组\t[{\"group_id\": \"grp_1\", \"group_name\": \"群组1\"}, {\"group_id\": \"grp_2\", \"group_name\": \"群组2\"}]\t\ngroups 数组中每个对象的结构:\n字段名\t类型\t可选\t描述\tgroup_id\tstring\t否\t群组的唯一 ID\tgroup_name\tstring\t否\t群组名称\tgroup_description\tstring\t是\t群组描述\tlast_message_snippet\tstring\t是\t最后一条消息摘要\tunread_count\tint\t是\t未读消息数（仅当查询特定用户时可用）\tuser_role\tenum\t是\t用户在群组中的角色，如果为 null 则表示用户不是群组成员","516-添加用户到群组-add-user-to-group#5.1.6. 添加用户到群组 (Add User to Group)":"群组管理员或具有相应权限的用户将另一用户添加到群组。\nADD_USER_TO_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"ADD_USER_TO_GROUP_REQUEST\"\n消息类型数字 ID: 520\nJSON 示例:\n{\n    \"message_id\": \"add_user_req_001\",\n    \"type\": \"ADD_USER_TO_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T14:00:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t目标群组的 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t要添加到群组的用户 ID\t\"usr_target_002\"\t\nADD_USER_TO_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"ADD_USER_TO_GROUP_RESPONSE\"\n消息类型数字 ID: 521\nJSON 示例 (成功):\n{\n    \"message_id\": \"add_user_resp_001\",\n    \"type\": \"ADD_USER_TO_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T14:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"add_user_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"User successfully added to group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"add_user_resp_002\",\n    \"type\": \"ADD_USER_TO_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T14:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"add_user_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Permission denied or user already in group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_002\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"用户成功添加到群组\"\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t被添加的用户 ID\t\"usr_target_002\"\t\nUSER_ADDED_TO_GROUP_NOTIFICATION (Server -> Group Members + Added User)\n消息类型 ID (type string): \"USER_ADDED_TO_GROUP_NOTIFICATION\"\n消息类型数字 ID: 522\nJSON 示例:\n{\n    \"message_id\": \"user_added_ntf_001\",\n    \"type\": \"USER_ADDED_TO_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T14:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"added_user_id\": \"usr_target_002\",\n        \"added_username\": \"New Member Alice\",\n        \"added_by_user_id\": \"usr_admin_001\",\n        \"added_by_username\": \"Admin John\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tadded_user_id\tstring\t否\t被添加用户的 ID\t\"usr_target_002\"\tadded_username\tstring\t否\t被添加用户的用户名\t\"新成员小爱\"\tadded_by_user_id\tstring\t否\t执行添加操作的用户 ID\t\"usr_admin_001\"\tadded_by_username\tstring\t否\t执行添加操作的用户名\t\"管理员张三\"","517-从群组移除用户-remove-user-from-group#5.1.7. 从群组移除用户 (Remove User from Group)":"群组管理员将用户从群组中移除。这与用户主动退出群组不同，因为它是由管理员或其他具有权限的用户发起的。\nREMOVE_USER_FROM_GROUP_REQUEST (Client -> Server)\n消息类型 ID (type string): \"REMOVE_USER_FROM_GROUP_REQUEST\"\n消息类型数字 ID: 523\nJSON 示例:\n{\n    \"message_id\": \"remove_user_req_001\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_REQUEST\",\n    \"timestamp\": \"2025-05-30T15:00:00Z\",\n    \"token\": \"admin_user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\",\n        \"reason\": \"Violation of group rules\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t要移除的用户 ID\t\"usr_target_003\"\treason\tstring\t是\t移除用户的原因（可选）\t\"违反群组规则\"\t\nREMOVE_USER_FROM_GROUP_RESPONSE (Server -> Client)\n消息类型 ID (type string): \"REMOVE_USER_FROM_GROUP_RESPONSE\"\n消息类型数字 ID: 524\nJSON 示例 (成功):\n{\n    \"message_id\": \"remove_user_resp_001\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T15:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"remove_user_req_001\",\n    \"payload\": {\n        \"success\": true,\n        \"message\": \"User successfully removed from group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"remove_user_resp_002\",\n    \"type\": \"REMOVE_USER_FROM_GROUP_RESPONSE\",\n    \"timestamp\": \"2025-05-30T15:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"remove_user_req_002\",\n    \"payload\": {\n        \"success\": false,\n        \"message\": \"Permission denied or user not in group\",\n        \"group_id\": \"grp_uuid_123\",\n        \"user_id\": \"usr_target_003\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tsuccess\tboolean\t否\t操作是否成功\ttrue\tmessage\tstring\t否\t操作结果信息\t\"用户成功从群组移除\"\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tuser_id\tstring\t否\t被移除的用户 ID\t\"usr_target_003\"\t\nUSER_REMOVED_FROM_GROUP_NOTIFICATION (Server -> Group Members + Removed User)\n消息类型 ID (type string): \"USER_REMOVED_FROM_GROUP_NOTIFICATION\"\n消息类型数字 ID: 525\nJSON 示例:\n{\n    \"message_id\": \"user_removed_ntf_001\",\n    \"type\": \"USER_REMOVED_FROM_GROUP_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T15:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"group_name\": \"Advanced Tech Group\",\n        \"removed_user_id\": \"usr_target_003\",\n        \"removed_username\": \"Former Member Dave\",\n        \"removed_by_user_id\": \"usr_admin_001\",\n        \"removed_by_username\": \"Admin John\",\n        \"reason\": \"Violation of group rules\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t群组 ID\t\"grp_uuid_123\"\tgroup_name\tstring\t否\t群组名称\t\"技术交流小组\"\tremoved_user_id\tstring\t否\t被移除用户的 ID\t\"usr_target_003\"\tremoved_username\tstring\t否\t被移除用户的用户名\t\"前成员小王\"\tremoved_by_user_id\tstring\t否\t执行移除操作的用户 ID\t\"usr_admin_001\"\tremoved_by_username\tstring\t否\t执行移除操作的用户名\t\"管理员张三\"\treason\tstring\t是\t移除用户的原因（可选）\t\"违反群组规则\"","52-消息收发-message-handling#5.2. 消息收发 (Message Handling)":"","521-发送群聊消息-send-group-chat-message#5.2.1. 发送群聊消息 (Send Group Chat Message)":"用户向指定群组发送一条文本消息。\nSEND_GROUP_CHAT_MESSAGE_REQUEST (Client -> Server)\n消息类型 ID (type string): \"SEND_GROUP_CHAT_MESSAGE_REQUEST\"\n消息类型数字 ID: 512\nJSON 示例:\n{\n    \"message_id\": \"send_grp_msg_req_001\",\n    \"type\": \"SEND_GROUP_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:00:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"content\": \"Hello everyone!\",\n        \"client_message_id\": \"client_msg_abc\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t目标群组的 ID\t\"grp_uuid_123\"\tcontent\tstring\t否\t消息的文本内容\t\"大家好！\"\tclient_message_id\tstring\t否\t客户端生成的消息唯一 ID (用于追踪和去重)\t\"client_msg_abc\"\t\nSEND_GROUP_CHAT_MESSAGE_ACK (Server -> Client, to Sender)\n消息类型 ID (type string): \"SEND_GROUP_CHAT_MESSAGE_ACK\"\n消息类型数字 ID: 513\nJSON 示例:\n{\n    \"message_id\": \"send_grp_msg_ack_001\",\n    \"type\": \"SEND_GROUP_CHAT_MESSAGE_ACK\",\n    \"timestamp\": \"2025-05-30T10:00:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"send_grp_msg_req_001\",\n    \"payload\": {\n        \"status_message\": \"Message received\",\n        \"server_message_id\": \"server_msg_xyz\",\n        \"client_message_id\": \"client_msg_abc\",\n        \"message_server_timestamp\": \"2025-05-30T10:00:01Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tstatus_message\tstring\t否\t服务器处理状态 (例如 \"消息已接收\")\t\"消息已接收\"\tserver_message_id\tstring\t否\t服务器为此消息生成的唯一 ID\t\"server_msg_xyz\"\tclient_message_id\tstring\t否\t回显客户端提供的 client_message_id\t\"client_msg_abc\"\tmessage_server_timestamp\tstring\t否\t消息在服务器被处理和存储的时间戳 (ISO8601)\t\"2025-05-30T10:00:01Z\"","522-接收群聊消息-receive-group-message#5.2.2. 接收群聊消息 (Receive Group Message)":"服务器将群聊消息广播给群组内的所有在线成员（通常不包括发送者自己，发送者通过 ACK 和本地 UI 更新）。\nRECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION (Server -> Client, to Group Members)\n消息类型 ID (type string): \"RECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION\"\n消息类型数字 ID: 514\nJSON 示例:\n{\n    \"message_id\": \"recv_grp_msg_ntf_001\",\n    \"type\": \"RECEIVE_GROUP_CHAT_MESSAGE_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:00:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"server_message_id\": \"server_msg_xyz\",\n        \"sender_user_id\": \"usr_sender_001\",\n        \"sender_username\": \"Sender John\",\n        \"content\": \"Hello everyone!\",\n        \"message_timestamp\": \"2025-05-30T10:00:01Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所属群组的 ID\t\"grp_uuid_123\"\tserver_message_id\tstring\t否\t服务器生成的消息唯一 ID\t\"server_msg_xyz\"\tsender_user_id\tstring\t否\t消息发送者的用户 ID\t\"usr_sender_001\"\tsender_username\tstring\t否\t消息发送者的用户名\t\"发送者小张\"\tcontent\tstring\t否\t消息的文本内容\t\"大家好！\"\tmessage_timestamp\tstring\t否\t消息在服务器的权威时间戳 (ISO8601)\t\"2025-05-30T10:00:01Z\"","523-撤回群聊消息-recall-group-chat-message#5.2.3. 撤回群聊消息 (Recall Group Chat Message)":"消息发送者请求撤回一条已发送的消息。服务器记录撤回状态并通知群成员。\nRECALL_GROUP_CHAT_MESSAGE_REQUEST (Client -> Server)\n消息类型 ID (type string): \"RECALL_GROUP_CHAT_MESSAGE_REQUEST\"\n消息类型数字 ID: 515\nJSON 示例:\n{\n    \"message_id\": \"recall_grp_msg_req_001\",\n    \"type\": \"RECALL_GROUP_CHAT_MESSAGE_REQUEST\",\n    \"timestamp\": \"2025-05-30T10:05:00Z\",\n    \"token\": \"user_session_token\",\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"server_message_id_to_recall\": \"server_msg_xyz\",\n        \"client_recall_request_id\": \"client_recall_req_789\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所在群组的 ID\t\"grp_uuid_123\"\tserver_message_id_to_recall\tstring\t否\t要撤回的消息的 server_message_id\t\"server_msg_xyz\"\tclient_recall_request_id\tstring\t是\t客户端生成的撤回请求 ID (用于追踪)\t\"client_recall_req_789\"\t\nGROUP_CHAT_MESSAGE_RECALLED_ACK (Server -> Client, to Sender of recall request)\n消息类型 ID (type string): \"GROUP_CHAT_MESSAGE_RECALLED_ACK\"\n消息类型数字 ID: 516\nJSON 示例 (成功):\n{\n    \"message_id\": \"recall_grp_msg_ack_001\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-30T10:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"recall_grp_msg_req_001\",\n    \"payload\": {\n        \"status_code\": 200,\n        \"status_message\": \"Message recalled successfully\",\n        \"recalled_server_message_id\": \"server_msg_xyz\",\n        \"client_recall_request_id\": \"client_recall_req_789\"\n    }\n}\nJSON 示例 (失败):\n{\n    \"message_id\": \"recall_grp_msg_ack_002\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALLED_ACK\",\n    \"timestamp\": \"2025-05-30T10:05:01Z\",\n    \"token\": null,\n    \"correlation_id\": \"recall_grp_msg_req_002\",\n    \"payload\": {\n        \"status_code\": 404,\n        \"status_message\": \"Message not found or already recalled\",\n        \"recalled_server_message_id\": \"server_msg_nonexist\",\n        \"client_recall_request_id\": \"client_recall_req_999\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tstatus_code\tint\t否\t撤回操作状态码 (例如 200 成功, 403 禁止, 404 未找到, 410 超时/窗口过期)\t200\tstatus_message\tstring\t否\t描述撤回操作结果的消息\t\"消息撤回成功\"\trecalled_server_message_id\tstring\t否\t被尝试撤回的消息的 server_message_id\t\"server_msg_xyz\"\tclient_recall_request_id\tstring\t是\t如果客户端在请求中提供了此 ID，服务器将其回显\t\"client_recall_req_789\"\t\nGROUP_CHAT_MESSAGE_RECALL_NOTIFICATION (Server -> Client, to Group Members)\n消息类型 ID (type string): \"GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION\"\n消息类型数字 ID: 517\nJSON 示例:\n{\n    \"message_id\": \"grp_msg_recalled_ntf_001\",\n    \"type\": \"GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION\",\n    \"timestamp\": \"2025-05-30T10:05:02Z\",\n    \"token\": null,\n    \"correlation_id\": null,\n    \"payload\": {\n        \"group_id\": \"grp_uuid_123\",\n        \"recalled_server_message_id\": \"server_msg_xyz\",\n        \"recalled_by_user_id\": \"usr_sender_001\",\n        \"recall_timestamp\": \"2025-05-30T10:05:00Z\"\n    }\n}\nPayload 参数:\n字段名\t类型\t可选\t描述\t示例\tgroup_id\tstring\t否\t消息所在群组的 ID\t\"grp_uuid_123\"\trecalled_server_message_id\tstring\t否\t被撤回消息的 server_message_id\t\"server_msg_xyz\"\trecalled_by_user_id\tstring\t否\t发起撤回操作的用户的 ID (即原消息发送者)\t\"usr_sender_001\"\trecall_timestamp\tstring\t否\t服务器处理撤回操作的时间戳 (ISO8601)\t\"2025-05-30T10:05:00Z\"\t\n客户端处理撤回通知的建议: 客户端在收到 GROUP_CHAT_MESSAGE_RECALL_NOTIFICATION 后，应在其本地消息列表中找到对应的 recalled_server_message_id 的消息，并将其标记为\"已撤回\"或替换为提示信息 (例如 \"[发送者] 撤回了一条消息\")，而不是直接删除，以保持对话上下文的连贯性。","数据结构定义-2#数据结构定义":"","groupuserrole#GroupUserRole":"用户在群组中的角色枚举，定义了用户在群组中的权限级别。\n枚举值\t描述\tOWNER\t群主，拥有所有权限，包括解散群组\tADMIN\t管理员，拥有管理成员和修改群信息的权限\tMEMBER\t普通成员，只有基本的发言和查看权限","7-通用错误响应-general-error-response#7. 通用错误响应 (General Error Response)":"","error_response-server---client#ERROR_RESPONSE (Server -> Client)":"消息类型 ID: 999\nJSON type 字符串: \"ERROR_RESPONSE\"\n{\n    \"message_id\": \"se1r0q9p-q6o5-5n23-9879-rqponmlkjihg\",\n    \"type\": \"ERROR_RESPONSE\",\n    \"timestamp\": \"2025-05-15T12:00:00Z\",\n    \"token\": null,\n    \"correlation_id\": \"failed_request_message_id\",\n    \"payload\": {\n        \"error_code\": 3002,\n        \"error_message\": \"Invalid username or password\",\n        \"error_details\": {\n            \"field\": \"password\",\n            \"attempted_username\": \"user123\"\n        },\n        \"retry_after\": null,\n        \"request_id\": \"req_abc123def456\"\n    }\n}\nPayload 参数:\n参数名\t类型\tOptional?\t描述\t示例\terror_code\tint\t否\t标准化错误代码，参见 error_codes.md。\t3002\terror_message\tstring\t否\t人类可读的错误描述。\t\"Invalid username or password\"\terror_details\tobject\t是\t可选的详细错误信息对象，包含特定错误的额外信息。\t{\"field\": \"password\"}\tretry_after\tint\t是\t建议客户端在多少秒后重试 (仅适用于临时错误，如速率限制)。\t60\trequest_id\tstring\t是\t服务器内部请求跟踪 ID，用于调试和日志关联。\t\"req_abc123def456\"\t\n附注:\n所有 timestamp 字段均使用 ISO 8601 格式的 UTC 时间，例如 YYYY-MM-DDTHH:MM:SSZ。\nmessage_id 和 correlation_id 推荐使用 UUID v4 格式。\nPydantic 模型在实际代码中定义了这些payload的结构，并负责验证和序列化/反序列化。\n消息类型 ID (如 101, 102) 需要在代码中与 MessageType 枚举和 JSON 中的 type 字符串保持一致。"}},"/sequence":{"title":"Sequence Flow","data":{"":"This section provides a detailed view of the message flow within the Whisper system, illustrating how different components interact during typical operations.","authentication-sequence#Authentication Sequence":"The following diagram illustrates the sequence of events that occurs when a message is sent from one user to another:","authentication-flow#Authentication Flow":"The following diagram illustrates the authentication process when a user logs into Whisper:","group-chat-creation#Group Chat Creation":"This diagram shows the process of creating a new group chat:","heartbeat-sequence#Heartbeat Sequence":"","private-message-sequence#Private Message Sequence":"","group-chat-sequence#Group Chat Sequence":""}},"/stress-test":{"title":"Dynamic Stress Testing","data":{"":"Running stress tests will generate significant load on the Whisper servers. Please use the test environment for these operations.","performance-under-load#Performance Under Load":"Whisper is designed to handle high volumes of concurrent connections and message exchanges. This page allows you to visualize the performance of Whisper under various load conditions through real-time testing.","testing-methodology#Testing Methodology":"Our stress testing approach evaluates several key metrics:\nConcurrent Connection Capacity: How many simultaneous WebSocket connections the system can maintain\nMessage Throughput: The number of messages that can be processed per second\nLatency: The time it takes for a message to travel from sender to recipient\nResource Utilization: CPU, memory, and network usage under load\nError Rates: The percentage of failed operations under various load conditions","test-scenarios#Test Scenarios":"The stress test dashboard allows you to run the following test scenarios:","scenario-1-gradual-connection-ramp-up#Scenario 1: Gradual Connection Ramp-Up":"This test gradually increases the number of concurrent connections to identify the system's scaling characteristics and potential breaking points.","scenario-2-message-burst-test#Scenario 2: Message Burst Test":"This test sends a sudden burst of messages from multiple clients to measure how the system handles traffic spikes.","scenario-3-long-running-stability-test#Scenario 3: Long-Running Stability Test":"This test maintains a steady load over an extended period to identify potential resource leaks or performance degradation over time.","scenario-4-mixed-workload-test#Scenario 4: Mixed Workload Test":"This test simulates a realistic usage pattern with a mix of different operations (sending messages, reading messages, creating groups, etc.).","interpreting-results#Interpreting Results":"The dashboard provides real-time visualizations of:\nActive connections over time\nMessage throughput (messages/second)\nMessage latency distribution\nError rates by operation type\nServer resource utilization\nWhen analyzing the results, pay attention to:\nInflection Points: Where performance metrics start to degrade\nError Rate Spikes: Sudden increases in failed operations\nLatency Increases: Growing delays in message delivery\nResource Saturation: CPU, memory, or network bottlenecks","system-optimizations#System Optimizations":"Based on stress test results, Whisper implements several optimizations:\nConnection Pooling: Efficient management of database connections\nMessage Batching: Grouping multiple messages into single database operations\nCaching Layer: In-memory caching of frequently accessed data\nLoad Balancing: Distribution of traffic across multiple server instances\nDatabase Sharding: Horizontal partitioning of data based on user or conversation IDs\nLazy Loading: Prioritizing critical data and deferring non-essential content\nThe stress test dashboard connects to Whisper's test environment. Results may vary compared to production performance due to different infrastructure configurations."}},"/uml":{"title":"UML Structure","data":{"":"This page presents the Unified Modeling Language (UML) diagrams that describe the architecture and class relationships of the Whisper Chat application.","core-component-structure#Core Component Structure":"The following class diagram illustrates the main components of the Whisper system and their relationships:","architecture-layers#Architecture Layers":"This diagram illustrates the layered architecture of the Whisper application:","message-encryption-flow#Message Encryption Flow":"The following diagram illustrates how message encryption works within Whisper:","notification-system#Notification System":"This diagram shows the components involved in Whisper's notification system:","websocket-connection-management#WebSocket Connection Management":"This diagram illustrates how Whisper manages WebSocket connections:","data-consistency-and-synchronization#Data Consistency and Synchronization":"This diagram illustrates Whisper's approach to data consistency and synchronization across devices:","server-architecture#Server Architecture":"This diagram shows the server-side architecture of Whisper:\nThese UML diagrams provide a comprehensive view of Whisper's architecture, helping developers understand how the various components work together to create a secure, efficient real-time communication system."}}}